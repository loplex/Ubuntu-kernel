#!/usr/bin/env python
#
# shank is the "stable bot" or "stab-bot".
#

from sys                                import argv
from os                                 import path
from getopt                             import getopt, GetoptError
from ktl.check_component                import CheckComponent
from ktl.utils                          import stdo, date_to_string, run_command
from ktl.ubuntu                         import Ubuntu
from ktl.std_app                        import StdApp
from ktl.workflow                       import Properties
from ktl.tracking_bug                   import TrackingBug
from lpltk.LaunchpadService             import LaunchpadService
from datetime                           import datetime
from urllib                             import quote
from urllib2                            import HTTPError
from ktl.messaging                      import Email, Status
from ktl.bugs                           import DeltaTime
from ktl.termcolor                      import colored
import re
import traceback
import json

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import info, debug, error, warning, basicConfig, INFO, DEBUG, WARNING
from sb.package                         import Package, PackageError
from sb.workflow_bug                    import WorkflowBug

def verbose(msg, color='green'):
    stdo(colored(msg, color))

def cinfo(msg, color='green'):
    info(colored(msg, color))

def cdebug(msg, color='red'):
    debug(colored(msg, color))

# Shank
#
class Shank(StdApp):
    # __init__
    #
    def __init__(s, args):
        StdApp.__init__(s)
        s.defaults = {}

        s.args = args

        s.state_map = {
            # Task, Current State, Action
            # Note: some tasks are only for and present in Kernel
            # Development Workflow, others only on SRU workflow
            'prepare-package'         : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.prep_package_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'upload-to-ppa'           : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':s.upload_to_ppa_confirmed},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-lbm'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.prep_package_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-lrm'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.prep_package_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-lum'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.prep_package_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-meta'    : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.prep_package_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-ports-meta':{'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.prep_package_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-signed'   : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.prep_package_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-proposed'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.promote_to_proposed_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'verification-testing'    : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.verification_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'certification-testing'   : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':s.certification_testing_invalid},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.certification_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'regression-testing'      : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':s.regression_testing_invalid},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.regression_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'package-testing'         : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.package_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-updates'      : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.check_for_final_close},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-security'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.check_for_final_close},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-release'      : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.promote_to_release_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'security-signoff'        : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':s.security_signoff_finished},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':s.security_signoff_finished},
                                         'Unknown' : {'action':None},
                                         },
        }

    def verbose(s, msg, color='green'):
        if s.args.verbose:
            stdo(colored(msg, color))

    # get_buglist
    #
    def get_buglist(s, project):
        '''
        Perform a search of Launchpad to get a list of all the bugs that match
        our criteria.

        A list of the bug ids is returned.
        '''
        retval = []

        search_tags            = [   # A list of the tags we care about
                'kernel-release-tracking-bug'
            ]
        search_tags_combinator = "All"
        search_status          = ["New", "In Progress", "Incomplete", "Fix Committed"] # A list of the bug statuses that we care about
        search_since           = datetime(year=2013, month=1, day=1)
        lp_project = s.lp.projects[project]
        tasks = lp_project.search_tasks(status=search_status, tags=search_tags, tags_combinator=search_tags_combinator, modified_since=search_since)

        for task in tasks:
            bug = task.bug
            info('found: %s' % bug.id)
            retval.append(bug.id)

        return retval

    # shank
    #
    def shank(s, bugid, sauron):
        s.printlink =  '%s : (%s)' % (bugid, s.bug_url(bugid)),
        info('')
        info('Processing: %s' % s.printlink)

        bug = WorkflowBug(s.lp, s.projects_tracked, bugid, sauron)
        if bug.is_valid:
            try:
                p = Package(s.lp, bug)
                info('')
                if p.is_released:
                    info('        The package has been promoted to the approriate release directories. Nothing more to be done.')

                elif p.is_prepd:
                    info('        The package and all of it\'s dependents have been fully prepared.')

                else:
                    info('        Needs work')
                    p.determine_build_status()

                s.process_bug_tasks(bug)

            except PackageError:
                pass

    # process_bug_tasks
    #
    def process_bug_tasks(s, shankbug):
        '''
        Go through every workflow task and perform the associated actions
        based on the current state (status) of that task.
        '''
        # Determine this bugs project.
        #
        for t in shankbug.lpbug.tasks:
            task_name       = t.bug_target_name
            if task_name in s.projects_tracked:
                s.projectname = task_name
                break
        master_task_name = s.projectname

        s.wfb = shankbug
        s.wfb.tasks_by_name = s.wfb.tasks_by_name

        # initialize any per-bug variables that we use
        s.bugtags = []
        for atag in shankbug.lpbug.tags:
            s.bugtags.append(atag)
        performReleaseTest = False
        s.certification_testing_complete = False
        s.regression_testing_complete = False
        s.security_signoff_complete = False
        s.security_publishing_required = False

        # Initialize the properties object
        s.props = Properties(shankbug.lpbug)

        # Go through each task.
        #
        info('')
        info('    Processing Workflow Tasks:')

        for workflow_task_name in sorted(shankbug.tasks_by_name):
            if workflow_task_name in ['kernel-sru-workflow', 'kernel-development-workflow']:
                continue

            task = shankbug.tasks_by_name[workflow_task_name]
            info("        %-25s  %15s  %10s  %s" % (task.name, task.status, task.importance, task.assignee))

            therest = task_name[len(master_task_name)+1:].strip()
            task_name = therest

            if workflow_task_name not in s.state_map:
                info('            ' + s.printlink)
                info('            Warning: I don\'t know how to handle the task <%s>, skipping' % (workflow_task_name))
                continue

            try:
                action = s.state_map[task.name][task.status]['action']

                if action is None:
                    info('            Action: No action for task %s in state %s' % (task.name, task.status))
                else:
                    res_action = action(t)
                    if s.projectname == 'kernel-sru-workflow' and res_action:
                        performReleaseTest = True

            except KeyError:
                info('            ' + s.printlink)
                info('            Error: No action found for state <%s> and task <%s>' % (task.status, task.name))

        # Now process any tests which require information from multiple tasks
        # will require info stored in class variables during task processing
        if performReleaseTest:
            s.perform_release_test()

        # Now flush any property changes to the bug description
        s.props.flush()
        s.verbose('--\n')

        return

    def bug_url(s, bug_id):
        if s.args.staging:
            lpserver = 'bugs.qastaging.launchpad.net'
        else:
            lpserver = 'bugs.launchpad.net'
        retval = 'https://%s/bugs/%s' % (lpserver, bug_id)
        return retval

    def send_comment(s, taskobj, subject, body):
        """
        Add comment to tracking bug
        """
        s.verbose('        ')
        if s.args.dryrun:
            s.verbose('Dryrun - Adding comment to tracking bug\n')
        else:
            s.verbose('Adding comment to tracking bug\n')
            taskobj.bug.add_comment(body, subject)

    def send_email(s, taskobj, subject, body, to_address=None):
        """
        Send email to the configured list or recipient
        """
        if s.args.dryrun:
            s.verbose('Dryrun - Sending email\n')
            return

        s.verbose('Sending email\n')

        if not 'mail_notify' in s.cfg:
            s.verbose('No mail_notify config found, can\'t send email\n')
            return

        mcfg = s.cfg['mail_notify']
        if not to_address:
            to_address = mcfg['to_address']
        body_top = 'The following message is regarding the following Kernel SRU Tracking bug:\n%s\n' % s.bug_url(taskobj.bug.id)
        body_top = body_top + ('%s\n\n' % s.wfb.title)
        msg = body_top + body
        subj =  '[ShankBot] ' + subject
        s.email.send(mcfg['from_address'], to_address, subj, msg)
        return

    def has_new_abi(s):
        tasks_abi = [ 'prepare-package-lbm', 'prepare-package-lrm',
                      'prepare-package-lum', 'prepare-package-meta',
                      'prepare-package-ports-meta' ]
        for taskname in tasks_abi:
            if taskname in s.wfb.tasks_by_name:
                if s.wfb.tasks_by_name[taskname].status != "Fix Released":
                    return False
        return True

    def send_upload_announcement(s, task, pocket):
        """
        Send email with upload announcement
        """
        s.verbose('        ')
        if s.args.dryrun:
            s.verbose('Dryrun - Sending upload announcement\n')
            return
        s.verbose('Sending upload announcement\n')

        from_addr = None
        if 'mail_notify' in s.cfg:
            if 'from_address' in s.cfg['mail_notify']:
                from_addr = s.cfg['mail_notify']['from_address']
        if not from_addr:
            s.verbose('        ')
            s.verbose('No valid email config found, can\'t'
                         ' send upload announcement\n')
            return

        dest  = "kernel-team@lists.ubuntu.com"
        dest += ", ubuntu-installer@lists.ubuntu.com"
        dest += ", gema.gomez-solano@canonical.com"
        if 'upload_announce_to' in s.cfg:
            for addr in s.cfg['upload_announce_to']:
                dest += ", %s" % (addr)

        bug = task.bug
        series = s.ubuntu.series_name(s.wfb.pkg_name, s.wfb.pkg_version)
        abi_bump = s.has_new_abi()

        subj = "[" + series + "] " + s.wfb.pkg_name + " " + s.wfb.pkg_version + " uploaded"
        if abi_bump:
            subj += " (ABI bump)"

        msg  = "A new " + series + " kernel has been uploaded into "
        msg += pocket + ". "
        if abi_bump:
            msg += "Note the ABI bump. "
        msg += "\nThe full changelog about all bug fixes contained in this "
        msg += "upload can be found at:\n\n"
        msg += "https://launchpad.net/ubuntu/" + series + "/+source/"
        msg += s.wfb.pkg_name + "/" + s.wfb.pkg_version + "\n\n"
        msg += "-- \nThis message was created by an automated script,"
        msg += " maintained by the\nUbuntu Kernel Team."

        s.email.send(from_addr, dest, subj, msg)
        return

    def send_status_update(s, taskobj, message):
        """
        Send a status update to twitter, status.net, identi.ca, etc
        """
        s.verbose('        ')
        if s.args.dryrun:
            s.verbose('Dryrun - Sending Status\n')
            return

        s.verbose('Sending Status\n')

        bugurl = quote(s.bug_url(taskobj.bug.id))

        kinfo = s.ubuntu.lookup(s.wfb.pkg_version.split('-')[0])
        series_name = kinfo['name']
        pkgid = '%s package %s %s ' % (series_name, s.wfb.pkg_name, s.wfb.pkg_version)

        s.status.update(bugurl + ' : ' + pkgid + ' ' + message)
        return

    def set_task_assignee(s, taskname, assignee):
        """
        Assign the task for the given assignee
        returns True if we changed the state and False if it was already at the desired state
        """
        if s.args.dryrun:
            s.verbose('        ')
            s.verbose('Dryrun - Assign task %s to %s\n' % (taskname, assignee))
            return

        # TODO could add error handling and retries here if needed
        new_assignee = None
        current_assignee = s.wfb.tasks_by_name[taskname].assignee
        if current_assignee and current_assignee.username != assignee.name:
            new_assignee = assignee
        elif not current_assignee:
            new_assignee = assignee
        if new_assignee:
            print('        Assigning Task <%s> to <%s>' % (taskname, assignee))
            s.wfb.tasks_by_name[taskname].assignee = assignee
            return True
        else:
            s.verbose('        ')
            s.verbose('Task <%s> already assigned to <%s>\n' % (taskname, assignee))
            return False

    def set_task_to_state(s, taskname, state):
        """
        Set a task with a given name to the desired state
        returns True if we changed the state and False if it was already at the desired state
        """
        if s.args.dryrun:
            s.verbose('        ')
            s.verbose('Dryrun - Set task %s to state %s\n' % (taskname, state))
            return

        s.verbose('        Setting %s to %s\n' % (taskname, state), 'red')
        # TODO could add error handling and retries here if needed
        if s.wfb.tasks_by_name[taskname].status != state:
            print('        Setting Task <%s> to State <%s>' % (taskname, state))
            s.wfb.tasks_by_name[taskname].status = state
            return True
        else:
            s.verbose('        ')
            s.verbose('Task <%s> already in state <%s>\n' % (taskname, state))
            return False

    # set_tagged_timestamp
    #
    def set_tagged_timestamp(s, taskobj, keyvalue):
        '''
        Add the supplied key with a timestamp. We do not replace existing keys
        '''
        if not s.args.dryrun and keyvalue not in taskobj.bug.properties:
            cinfo('        Adding tagged timestamp <%s> to tracking bug' % keyvalue)

            now = datetime.utcnow()
            now.replace(tzinfo=None)
            tstamp = date_to_string(now)
            props = {keyvalue:tstamp}
            s.props.set(props)

    # set_phase
    #
    """
    Add the phase we're entering as a 'property',
    along with a time stamp
    """
    def set_phase(s, taskobj, phasetext):
        bug_prop = 'kernel'
        if s.projectname == 'kernel-sru-workflow':
            bug_prop += '-stable'
        bug_prop += '-phase'
        bug_prop_chg = bug_prop + '-changed'
        # We have to check here to see whether the same status is already set,
        # or we will overwrite the timestamp needlessly
        if bug_prop in taskobj.bug.properties:
            if taskobj.bug.properties[bug_prop] == phasetext:
                # we already have this one
                s.verbose('        ')
                s.verbose('Not overwriting identical phase property\n')
                return
        # Handle dryrun mode
        s.verbose('        ')
        if s.args.dryrun:
            s.verbose('Dryrun - Changing bug phase to <%s>\n' % phasetext)
            return
        else:
            s.verbose('Changing bug phase to <%s>\n' % phasetext)
        # Add phase and time stamp
        now = datetime.utcnow()
        now.replace(tzinfo=None)
        tstamp = date_to_string(now)
        props = {bug_prop:phasetext, bug_prop_chg:tstamp}
        s.props.set(props)

    #
    # Begin action methods for state transitions
    #

    # master_bug_property_name
    #
    @property
    def master_bug_property_name(s):
        retval = 'kernel'
        if s.projectname == 'kernel-sru-workflow':
            retval += '-stable'
        retval += '-master-bug'
        return retval

    # is_derivative_package
    #
    def is_derivative_package(s, bug):
        return s.master_bug_property_name in bug.properties

    # master_bug
    #
    def master_bug(s, bug):
        '''
        Find the 'master' bug of which this is a derivative and return that bug.
        '''
        return s.lp.get_bug(bug.properties[s.master_bug_property_name])

    # check_master_task
    #
    def check_master_task(s, bug, tasks):
        """
        check if the dictionary of tasks is in one of the provided list of
        status on the master bug listed in the bug, returns:
        * -1 if we were unable to check the status
        * 0 if the task on the master tracking bug is not Confirmed/ Fix Released
        * 1 if this isn't a derivative (doesn't have a master tracking bug
        * 2 if the task on the master tracking bug is Confirmed or Fix Released
        The tasks provided must be a dictionary in the form:
            'task name' : [ list of desired status ]
        """
        master_bug_missing     = -1
        master_bug_bad_status  = 0
        master_bug_good_status = 2
        not_derivative         = 1

        retval = not_derivative
        if s.is_derivative_package(bug):
            try:
                master = s.master_bug(bug)

                retval = master_bug_good_status
                for task in master.tasks:
                    task_name = task.bug_target_name

                    if (not task_name.startswith(s.projectname) or task_name == s.projectname):
                        continue

                    short_name = task_name[len(s.projectname)+1:].strip()
                    for tname in iter(tasks):
                        if short_name.lower() == tname:
                            if not task.status in tasks[tname]:
                                retval = master_bug_bad_status
                                s.verbose("%s doesn't match any of these " "status in bug %s: %s." % (tname, master.id, tasks[tname]))
                                s.verbose(" Waiting on master bug\n")
                            return retval
            except:
                traceback.print_exc()
                print("ERROR: Unable to get the master bug\n")
                retval = master_bug_missing

        return retval

    def prepare_package_fixed(s):
        """
        Check if all prepare-package tasks are finished, returning a
        boolean value indicating so
        """
        for task in iter(s.wfb.tasks_by_name):
            if task.startswith('prepare-package'):
                if (s.wfb.tasks_by_name[task].status != 'Fix Released' and
                    s.wfb.tasks_by_name[task].status != 'Invalid'):
                    return False
        return True

    def upload_to_ppa_confirmed(s, taskobj):
        s.set_phase(taskobj, 'ReadyToBePackaged')
        return True

    def prep_package_fix_released(s, taskobj):
        """
        when the prep-package task is set to Fix Released and there is
        no upload-to-ppa task, we create new tracking bugs for
        derivative packages, and set the promote-to-proposed task to
        Confirmed. Otherwise, if upload-to-ppa task is present, just set
        it to Confirmed if necessary
        """
        s.verbose('            prep_package_fix_relesed\n', 'blue')  # FIXME bjf - debugging

        if s.projectname == 'kernel-sru-workflow':
            taskname = 'promote-to-proposed'
        else:
            taskname = 'package-testing'

        s.verbose('                %s status: %s\n' % (taskname, s.wfb.tasks_by_name[taskname].status), 'blue')  # FIXME bjf - debugging

        # Even though we came in here do to one of the prepare-package* tasks being
        # set to 'Fix Released' we don't actually do anything unless the next state
        # (promote-to-proposed or package-testing) is 'New'.
        #
        if s.wfb.tasks_by_name[taskname].status == 'New':
            # check if all prepare-package tasks are finished
            if not s.prepare_package_fixed():
                s.verbose('                prepare_package_fixed: false\n', 'blue')  # FIXME bjf - debugging
                return False

            # if this is a derivative tracking bug, first wait until
            # that packages on the master tracking bug are also ready or
            # already promoted. The way derivative package bugs are
            # opened already ensures this, but check the tasks on the
            # master bug anyway just in case...
            tsk_st = {
                'prepare-package'            : [ 'Fix Released' ],
                'prepare-package-lbm'        : [ 'Fix Released', 'Invalid' ],
                'prepare-package-lrm'        : [ 'Fix Released', 'Invalid' ],
                'prepare-package-lum'        : [ 'Fix Released', 'Invalid' ],
                'prepare-package-meta'       : [ 'Fix Released', 'Invalid' ],
                'prepare-package-ports-meta' : [ 'Fix Released', 'Invalid' ],
                'prepare-package-signed'     : [ 'Fix Released' ],
                taskname                     : [ 'Confirmed', 'Fix Released' ]
            }
            # If the master bug's tasks are not completely ready.
            #
            if s.check_master_task(taskobj.bug, tsk_st) <= 0:
                s.verbose('                check_master_task: false\n', 'blue')  # FIXME bjf - debugging
                return False

            # open new tracking bugs for derivative packages if needed
            series = s.ubuntu.series_name(s.wfb.pkg_name, s.wfb.pkg_version)
            if not series:
                print("ERROR: Can't find series for %s-%s to get derivatives\n" % (s.wfb.pkg_name, s.wfb.pkg_version))
                return False

            der_list = []
            record = s.ubuntu.lookup(series)
            if 'derivative-packages' in record:
                if s.wfb.pkg_name in record['derivative-packages']:
                    der_list = record['derivative-packages'][s.wfb.pkg_name]
            bp_list = []
            for entry in s.ubuntu.db.itervalues():
                if 'backport-packages' in entry:
                    bp_entries = entry['backport-packages']
                    for bp_entry in iter(bp_entries):
                        if (bp_entries[bp_entry][0] == s.wfb.pkg_name and bp_entries[bp_entry][1] == record['series_version']):
                            bp_list.append([bp_entry, entry['name']])

            der_bug_list = []
            bp_bug_list  = []
            m_bug_list   = []

            tb = TrackingBug(s.lp, s.args.staging)
            for der_pkg in der_list:
                if s.args.dryrun:
                    s.verbose('        ')
                    s.verbose('Dryrun - Would open tracking bug for derivative package %s\n' % (der_pkg))
                    continue
                try:
                    print('        ')
                    bug = tb.open(der_pkg, '<version to be filled>', True, taskobj.bug.id, series)
                except:
                    traceback.print_exc()
                    bug = None
                if bug:
                    # Friendly comment on the bug stating that this is a derivative
                    msgder =  "This tracking bug was opened to be worked from "
                    msgder += "%s-%s update (bug %s)" % (s.wfb.pkg_name, s.wfb.pkg_version, taskobj.bug.id)
                    subder =  "Derivative package tracking bug"
                    bug.add_comment(msgder, subder)
                    print '        Action: Opened tracking bug %s for derivative package %s\n' % (bug.id, der_pkg)
                    der_bug_list.append([der_pkg, bug.id])
                else:
                    m_bug_list.append('%s' % (der_pkg))

            for bp_pkg in bp_list:
                if s.args.dryrun:
                    s.verbose('        ')
                    s.verbose('Dryrun - Would open tracking bug for backport package %s\n' % (bp_pkg[0]))
                    continue
                try:
                    bug = tb.open(bp_pkg[0], '%s~%s1' % (s.wfb.pkg_version, bp_pkg[1]), s.has_new_abi(), taskobj.bug.id)
                except:
                    traceback.print_exc()
                    bug = None
                if bug:
                    print('        Action: Opened tracking bug %s for backport package %s (%s)\n' % (bug.id, bp_pkg[0], bp_pkg[1]))
                    bp_bug_list.append([bp_pkg[0], bp_pkg[1], bug.id])
                else:
                    m_bug_list.append('%s (%s)' % (bp_pkg[0], bp_pkg[1]))

            # comment about publishing and possible new tracking bugs opened
            msgbody  = 'All builds are complete, packages in this bug'
            if taskname == 'promote-to-proposed':
                msgbody += ' can be copied to -proposed.'
            else:
                msgbody += ' are available in -proposed.'
            if der_bug_list:
                msgbody += '\n\nDerivative packages from packages here can be worked on,'
                msgbody += ' the following tracking bugs were opened for them:'
                for pkg_bug in der_bug_list:
                    msgbody += '\n%s - bug %s' % (pkg_bug[0], pkg_bug[1])
            if bp_bug_list:
                msgbody += '\n\nBackport packages from packages here can be worked on,'
                msgbody += ' the following tracking bugs were opened for them:'
                for pkg_bug in bp_bug_list:
                    msgbody += '\n%s (%s) - bug %s' % (pkg_bug[0], pkg_bug[1], pkg_bug[2])
            if m_bug_list:
                msgbody += '\n\nIt was not possible to create or handle the'
                msgbody += ' tracking bugs for the following packages'
                msgbody += ' (their tracking bugs based on this update'
                msgbody += ' must be handled manually):'
                for ln in m_bug_list:
                    msgbody += '\n%s' % (ln)
            task = s.wfb.tasks_by_name[s.projectname]
            s.send_comment(task, 'Packages available', msgbody)

            # Set promote-to-proposed
            s.set_task_to_state(taskname, 'Confirmed')
            # Add time stamp and status
            if s.projectname == 'kernel-sru-workflow':
                s.set_tagged_timestamp(taskobj, 'kernel-stable-Prepare-package-end')
                s.set_tagged_timestamp(taskobj, 'kernel-stable-Promote-to-proposed-start')
                s.set_phase(taskobj, 'CopyToProposed')
            else:
                s.set_tagged_timestamp(taskobj, 'kernel-Prepare-package-end')
                s.set_tagged_timestamp(taskobj, 'kernel-Package-testing-start')
                s.set_phase(taskobj, 'Testing')
                s.send_upload_announcement(taskobj, 'proposed')

                cmd = 'ssh zinc.canonical.com \'echo "<html>%s</html>" > /srv/kernel.ubuntu.com/www/kernel-pkg-status/%s.html\'' % (s.wfb.title, series)
                status, result = run_command(cmd)

        return False

    def has_prep_task(s, taskname):
        if taskname in s.wfb.tasks_by_name:
            if s.wfb.tasks_by_name[taskname].status == "Fix Released":
                return True
        return False

    def check_component_in_pocket(s, taskobj, tstamp_prop, pocket):
        """
        Check if packages for the given tracking bug were properly copied
        to the right component in the given pocket.
        """
        bug = taskobj.bug

        # Set promote-to-proposed timestamp first, used for checking below
        s.set_tagged_timestamp(taskobj, tstamp_prop)

        # Wait publishing tasks to complete. Usually archive admin sets
        # the promote-to-<pocket> task to Fix Released right away after
        # doing the copy, but actual publishing takes more time. It's
        # said that the publishing should take at most 1 hour to
        # complete, but could be a bit more in some cases, or could
        # vary. Anyway, just wait arbitrarily 1 hour before we do the
        # actual processing, to avoid sru-workflow-manager to complain
        # about packages in wrong component while real copying/publishing
        # still didn't finish
        if tstamp_prop in bug.properties:
            date_str = bug.properties[tstamp_prop]
            timestamp = datetime.strptime(date_str, '%A, %d. %B %Y %H:%M UTC')
            delta = DeltaTime(timestamp, datetime.utcnow())
            if delta.hours < 1:
                s.verbose('Waiting 1 hour after promote-to-%s was Fix Released\n'
                             % (pocket))
                return False
        else:
            return False

        # Do the checking for proper packages in pocket->component
        series_name = s.ubuntu.series_name(s.wfb.pkg_name, s.wfb.pkg_version)
        check_component = CheckComponent(s.lp)
        name_meta = 'linux-meta'
        name_ports_meta = 'linux-ports-meta'
        name_signed = 'linux-signed'
        name_split = s.wfb.pkg_name.split('-', 1)
        if len(name_split) > 1:
            name_meta = '%s-meta-%s' % (name_split[0], name_split[1])
            name_ports_meta = '%s-ports-meta-%s' % (name_split[0], name_split[1])
            name_signed = '%s-signed-%s' % (name_split[0], name_split[1])
        name_map = { 'prepare-package-lbm' : 'linux-backports-modules',
                     'prepare-package-lrm' : 'linux-restricted-modules',
                     'prepare-package-lum' : 'linux-ubuntu-modules',
                     'prepare-package-meta' : name_meta,
                     'prepare-package-ports-meta' : name_ports_meta,
                     'prepare-package-signed' : name_signed }
        ver_split = s.wfb.pkg_version.split('-')
        main_version = ver_split[0]
        pkg_list = [ s.wfb.pkg_name ]
        for name in iter(name_map):
            if s.has_prep_task(name):
                if ('lbm' in name) or ('lrm' in name) or ('lum' in name):
                    pkg_list.append('%s-%s' % (name_map[name], main_version))
                else:
                    pkg_list.append(name_map[name])
        missing_pkg = []
        pkg_abi = ''
        dep_ver1 = main_version
        dep_ver2 = main_version
        if len(ver_split) > 1:
            pkg_abi = ver_split[1].split('.')[0]
            dep_ver1 = '%s-%s' % (main_version, pkg_abi)
            dep_ver2 = '%s.%s' % (main_version, pkg_abi)
        mis_lst = []
        for pkg in pkg_list:
            if pkg == s.wfb.pkg_name:
                check_ver = s.wfb.pkg_version
            else:
                check_ver = None
            ps = check_component.get_published_sources(series_name, pkg,
                                                       check_ver, pocket)
            if not ps:
                if check_ver:
                    missing_pkg.append([pkg, check_ver])
                elif pkg == name_signed:
                    missing_pkg.append([pkg, 'for version=%s' % (s.wfb.pkg_version)])
                else:
                    missing_pkg.append([pkg, 'with ABI=%s' % (pkg_abi)])
                continue
            if pkg == name_signed:
                src_ver = ps[0].source_package_version
                if src_ver.startswith(s.wfb.pkg_version):
                    mis_lst.extend(check_component.mismatches_list(series_name,
                                   pkg, ps[0].source_package_version,
                                   pocket, ps))
                else:
                    missing_pkg.append([pkg, 'for version=%s' % (s.wfb.pkg_version)])
            elif not check_ver:
                src_ver = ps[0].source_package_version
                # special hardcoded case for lrm on hardy...
                if pkg == 'linux-restricted-modules-2.6.24':
                    src_split = src_ver.split('-')
                    if src_split[0].startswith(main_version) and len(src_split) > 1:
                        src_ver = '%s-%s' % (main_version, src_split[1])
                if src_ver.startswith(dep_ver1) or src_ver.startswith(dep_ver2):
                    mis_lst.extend(check_component.mismatches_list(series_name,
                                   pkg, ps[0].source_package_version,
                                   pocket, ps))
                else:
                    missing_pkg.append([pkg, 'with ABI=%s' % (pkg_abi)])
            else:
                mis_lst.extend(check_component.mismatches_list(series_name,
                               pkg, check_ver, pocket, ps))
        if not missing_pkg:
            if mis_lst:
                s.set_task_to_state('promote-to-%s' % (pocket), 'Incomplete')
                msgbody  = "The following packages ended up in the wrong"
                msgbody += " component in the -%s pocket:\n" % (pocket)
                for item in mis_lst:
                    msgbody += '\n%s %s - is in %s instead of %s' % (item[0],
                               item[1], item[2], item[3])
                bugbody = msgbody
                bugbody += "\n\nOnce this is fixed, set the "
                bugbody += "promote-to-%s to Fix Released again" % (pocket)
                s.send_comment(taskobj, 'Packages outside of proper component', bugbody)
                if not s.args.dryrun:
                    s.props.set({tstamp_prop:None})
                s.send_email(taskobj, '[bug %s] Packages copied to the wrong component'
                                % (bug.id), msgbody)
                return False
        else:
            # Even if we already waited 1 hour, wait more (1 day) before
            # complaining if we don't find the packages published to
            # the pocket, in case the copy/publishing take more hours
            # after promote-to-<pocket> is set to Fix Released the first
            # time
            if delta.days >= 1:
                s.set_task_to_state('promote-to-%s' % (pocket), 'Incomplete')
                msgbody  = "Promote-to-%s is Fix Released, but " % (pocket)
                msgbody += "some packages for this update aren't published "
                msgbody += "in Launchpad, on -%s pocket:\n" % (pocket)
                for item in missing_pkg:
                    msgbody += '\n%s %s' % (item[0], item[1])
                s.send_comment(taskobj, 'Can\'t find packages published in -%s' %
                                  (pocket), msgbody)
                if not s.args.dryrun:
                    s.props.set({tstamp_prop:None})
                return False
            for item in missing_pkg:
                cinfo('Didn\'t find <%s> <%s> on -%s yet' % (item[0], item[1], pocket), 'red')
            return False

        return True

    def promote_to_proposed_fix_released(s, taskobj):
        """
        When promote-to-proposed is set to Fix Released, we begin verification testing by setting
        verification-testing to In Progress, add tags to the bugs, and spam with text
        """
        # Exit if processed already
        task = s.wfb.tasks_by_name['verification-testing']
        if task.status != 'New':
            return False

        # Check if packages were copied to the right pocket->component
        if not s.check_component_in_pocket(taskobj,
                'kernel-stable-Promote-to-proposed-end',
                'proposed'):
            return False

        # Update remaining time stamps and status, send announcement
        s.set_tagged_timestamp(taskobj, 'kernel-stable-Verification-testing-start')
        s.set_phase(taskobj, 'Verification')
        s.set_task_to_state('verification-testing', 'In Progress')
        s.send_upload_announcement(taskobj, 'proposed')

        # Now tag all bugs verification-needed and spam with a comment
        # Automate this in the future but for now send an email
        print s.printlink,
        print 'Here is where we would tag and spam the verification bugs'
        return False

    def verification_testing_fix_released(s, taskobj):
        """
        When verification-testing is set to Fix Released, we set three tasks to Confirmed.
        These are certification-testing, regression-testing, and security-signoff
        """
        # Add time stamp and status
        if ((s.wfb.tasks_by_name['certification-testing'].status != 'Fix Released' and
             s.wfb.tasks_by_name['certification-testing'].status != 'Invalid') or
            (s.wfb.tasks_by_name['security-signoff'].status != 'Fix Released' and
             s.wfb.tasks_by_name['security-signoff'].status != 'Invalid') or
            (s.wfb.tasks_by_name['regression-testing'].status != 'Fix Released' and
             s.wfb.tasks_by_name['regression-testing'].status != 'Invalid')):
            s.set_tagged_timestamp(taskobj, 'kernel-stable-Verification-testing-end')
            s.set_phase(taskobj, 'Testing')

        if s.wfb.tasks_by_name['certification-testing'].status == 'New':
            s.set_task_to_state('certification-testing', 'Confirmed')
            s.set_tagged_timestamp(taskobj, 'kernel-stable-Certification-testing-start')
        if s.wfb.tasks_by_name['regression-testing'].status == 'New':
            s.set_task_to_state('regression-testing', 'Confirmed')
            s.set_tagged_timestamp(taskobj, 'kernel-stable-Regression-testing-start')
        if s.wfb.tasks_by_name['security-signoff'].status == 'New':
            s.set_task_to_state('security-signoff', 'Confirmed')
            s.set_tagged_timestamp(taskobj, 'kernel-stable-Security-signoff-start')
        return False

    def certification_testing_fix_released(s, taskobj):
        """
        When certification-testing is set to Fix Released, we check the tags
        If tagged certification-testing-failed then we alert people
        If certification-testing-passed then we save the tag and state and trigger
        running of the test to see if we're ready for publishing
        """
        if 'certification-testing-failed' in s.bugtags:
            s.verbose('Certification tagged as FAIL\n')
            s.set_tagged_timestamp(taskobj, 'kernel-stable-Certification-testing-end')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The bug was tagged as certification-testing-failed\n'
            s.send_comment(taskobj, 'Certification FAILURE', msgbody)
            # stop further processing by this bot
            s.set_task_to_state(s.projectname, 'Incomplete')
            s.set_phase(taskobj, 'TestFail')
            return False
        elif 'certification-testing-passed' in s.bugtags:
            s.verbose('Certification tagged as PASSED\n')
            s.set_tagged_timestamp(taskobj, 'kernel-stable-Certification-testing-end')
            # TODO send a status.net update?
            s.certification_testing_complete = True
            return True
        else:
            s.verbose('certification-testing task set to Fix Released but no status tag!\n')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The certification-testing task was set to Fix Released but neither the certification-testing-passed or certification-testing-failed tag was applied\n'
            s.send_comment(taskobj, 'Certification completed but no status tags applied', msgbody)
            # reset task state so Certification team fixes it
            s.set_task_to_state('certification-testing', 'Incomplete')
            return False

    def certification_testing_invalid(s, taskobj):
        """
        When certification-testing is set to Invalid, this indicates
        that certification testing will not be performed on this release.
        We consider the task to be 'done' in that we trigger a release test,
        but we don't check any tags
        """
        s.certification_testing_complete = True
        s.set_tagged_timestamp(taskobj, 'kernel-stable-Certification-testing-end')
        return True

    def regression_testing_invalid(s, taskobj):
        """
        When regression-testing is Invalid, it means we want to skip
        testing for that update. So just ignore and return the value to
        perform the release test
        """
        s.regression_testing_complete = True
        return True

    def regression_testing_fix_released(s, taskobj):
        """
        When regression-testing is set to Fix Released, we check the tags
        If tagged qa-testing-failed then we alert people
        If qa-testing-passed then we save the tag and state and trigger
        running of the test to see if we're ready for publishing
        """
        if 'qa-testing-failed' in s.bugtags:
            s.verbose('Regression Testing tagged as FAIL\n')
            s.set_tagged_timestamp(taskobj, 'kernel-stable-Regression-testing-end')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The bug was tagged as qa-testing-failed\n'
            s.send_comment(taskobj, 'Regression Testing FAILURE', msgbody)
            # stop further processing by this bot
            s.set_task_to_state(s.projectname, 'Incomplete')
            s.set_phase(taskobj, 'TestFail')
            return False
        elif 'qa-testing-passed' in s.bugtags:
            s.verbose('Regression Testing tagged as PASSED\n')
            s.set_tagged_timestamp(taskobj, 'kernel-stable-Regression-testing-end')
            # TODO send a status.net update?
            s.regression_testing_complete = True
            return True
        else:
            s.verbose('regression-testing task set to Fix Released but no status tag!\n')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The regression-testing task was set to Fix Released but neither the qa-testing-passed or qa-testing-failed tag was applied\n'
            s.send_comment(taskobj, 'Regression Testing completed but no status tags applied', msgbody)
            # reset task so QA team can fix it
            s.set_task_to_state('regression-testing', 'Incomplete')
            # stop further processing by this bot
            s.set_task_to_state(s.projectname, 'Incomplete')
            s.set_phase(taskobj, 'OnHold')
            return False

    def package_testing_fix_released(s, taskobj):
        """
        When package-testing is set to Fix Released, that means the
        development kernel passed all wanted testing and is acked to go
        to the release pocket by the Ubuntu Kernel Team
        """
        if s.wfb.tasks_by_name['promote-to-release'].status == 'New':
            # if this is a derivative tracking bug, first wait until
            # that packages on the master tracking bug are also ready or
            # already promoted. The way derivative package bugs are
            # opened already ensures this, but check the tasks on the
            # master bug anyway just in case...
            tsk_st = { 'promote-to-release' : [ 'Confirmed', 'Fix Released' ] }

            # If the master bug's tasks are not completely ready.
            #
            if s.check_master_task(taskobj.bug, tsk_st) <= 0:
                return False

            # Set promote-to-proposed
            s.set_task_to_state('promote-to-released', 'Confirmed')
            # Add time stamp and status
            s.set_tagged_timestamp(taskobj, 'kernel-Package-testing-end')
            s.set_tagged_timestamp(taskobj, 'kernel-Promote-to-release-start')
            s.set_phase(taskobj, 'CopyToRelease')
        return False

    def promote_to_release_fix_released(s, taskobj):
        """
        When promote-to-release is set to Fix Released, the development
        kernel is copied to the -release pocket, marking the end of the
        workflow for it. Some final checks are done here to verify that
        everything is ok
        """

        # Ensure all tasks are closed
        if not s.prepare_package_fixed():
            return
        if (s.wfb.tasks_by_name['package-testing'].status != 'Fix Released' or
            s.wfb.tasks_by_name['package-testing'].status != 'Invalid'):
            s.wfb.tasks_by_name['package-testing'].status = "Won't Fix"

        # Do we halted processing?
        if (s.wfb.tasks_by_name[s.projectname].status != 'In Progress'):
            s.verbose('*** promote-to-release halted on bug with status!=In Progress\n')
            return

        if not s.check_component_in_pocket(taskobj,
                    'kernel-Promote-to-release-end',
                    'release'):
            return False

        s.set_task_to_state(s.projectname, 'Fix Released')
        s.set_phase(taskobj, 'Released')
        msgbody = 'The package has been published and the bug is being set to Fix Released\n'
        s.send_comment(taskobj, 'Package Released!', msgbody)
        s.send_status_update(taskobj, 'has been published.')

    def security_signoff_finished(s, taskobj):
        """
        When security-signoff is set to either Invalid or Fix Released, it is done.
        If set to Fix Released, we set a flag to indicate that the package must
        be copied to the -security pocket.
        """
        s.security_signoff_complete = True
        s.set_tagged_timestamp(taskobj, 'kernel-stable-Security-signoff-end')
        # Trigger the release test
        return True

    def release_test_state_check(s, taskname, desired_state_list):
        taskobj = s.wfb.tasks_by_name[taskname]
        if taskobj.status not in desired_state_list:
            s.verbose('ERROR: %s task set to Unexpected state!\n' % taskname)
            # Send email and possibly a status update
            msgbody = 'The %s task was not set to one of the following states during the release test:\n' % taskname
            for statename in desired_state_list:
                msgbody = msgbody + statename + ', '
            msgbody = msgbody + '\n'
            msgbody = msgbody + '%s task was set to state %s\n' % (taskname, taskobj.status)
            msgbody = msgbody + 'Further processing of this bug by Workflow Manager is halted.\n'
            s.send_comment(taskobj, '%s task not set to correct state during release test' % taskname, msgbody)
            # stop further processing by this bot
            s.set_task_to_state(s.projectname, 'Incomplete')

    def hold_updates_security_copy(s):
        """
        The security team wants to avoid updates being copied to
        security/updates on Friday before the weekend. If there is some
        last minute crisis/regression on the kernel copied to
        -updates/-security, there are little resources to deal with this
        on the weekend. Also USN processing may be affected the by time
        of the kernel release. It was agreed that we should delay kernel
        copying to -updates/-security if we are between 1800UTC Fri -
        2100UTC Sun, this function is used to check that so we delay
        setting the promote to -updates/-security tasks to Confirmed.
        """
        now = datetime.utcnow()
        wday = now.weekday()
        if wday == 5:
            return True
        if wday == 4 and now.hour >= 18:
            return True
        if wday == 6 and now.hour < 21:
            return True
        return False

    #
    # This is not performed during processing for a specific task but only if several tasks are
    # in the correct state
    #
    # perform_release_test
    #
    def perform_release_test(s):
        """
        Check results from multiple tasks to see whether release
        to -updates and -security are required
        """
        s.verbose('*** Performing release test\n')

        # No need to do anything until these three are all complete
        if (s.certification_testing_complete and s.regression_testing_complete and s.security_signoff_complete):
            s.verbose('Cert and regression testing and security signoff all complete\n')

            # Some general sanity checks before we pull the lever to publish
            s.release_test_state_check('prepare-package', ['Fix Released'])
            s.release_test_state_check('promote-to-proposed', ['Fix Released'])
            s.release_test_state_check('verification-testing', ['Fix Released'])
            s.release_test_state_check('certification-testing', ['Invalid', 'Fix Released'])
            s.release_test_state_check('regression-testing', ['Invalid', 'Fix Released'])
            s.release_test_state_check('security-signoff', ['Invalid', 'Fix Released'])
            # confirmed is in the next two in case we rerun the release test after
            # a dumb failure like email send fail or something
            s.release_test_state_check('promote-to-security', ['New', 'Confirmed', 'Invalid', 'Incomplete', 'Fix Released'])
            s.release_test_state_check('promote-to-updates', ['New', 'Confirmed', 'Incomplete', 'Fix Released'])

            # If we found any problems, we've halted processing and set this
            if (s.wfb.tasks_by_name[s.projectname].status != 'In Progress' or
                s.wfb.tasks_by_name['promote-to-security'].status == 'Incomplete' or
                s.wfb.tasks_by_name['promote-to-updates'].status == 'Incomplete'):
                s.verbose('*** Exiting release test without triggering any publishing\n')
                return

            if ((s.wfb.tasks_by_name['promote-to-security'].status == 'Confirmed' or
                 s.wfb.tasks_by_name['promote-to-security'].status == 'Invalid') and
                s.wfb.tasks_by_name['promote-to-updates'].status == 'Confirmed'):
                s.verbose('*** Exiting release test, all set\n')
                return

            if s.wfb.tasks_by_name['security-signoff'].status == 'Fix Released':
                # publishing to security is required
                s.security_publishing_required = True

            # one last check for test results
            if ('qa-testing-passed' in s.bugtags or s.wfb.tasks_by_name['regression-testing'].status == 'Invalid') and \
                    ('certification-testing-passed' in s.bugtags or s.wfb.tasks_by_name['certification-testing'].status == 'Invalid'):

                # We don't publish on Fri/Sat/Sun (see comment on function
                # hold_updates_security_copy). Also, only allow the
                # promote-to-{updates,security} on derivative packages
                # if the master packages are already ready for promotion
                # or already promoted to the updates/security pockets.
                tbug = s.wfb.tasks_by_name[s.projectname].bug
                tsk_st = { 'promote-to-updates' : [ 'Confirmed', 'Fix Released' ],
                           'promote-to-security' : [ 'Confirmed', 'Fix Released', 'Invalid' ] }
                if (not s.hold_updates_security_copy() and s.check_master_task(tbug, tsk_st) > 0):
                    task = s.wfb.tasks_by_name[s.projectname]
                    # If this is a derivative, it's supposed to be
                    # rebased on top of master, or to have security
                    # fixes as master has. Thus, we also enable
                    # publishing to the security pocket for the
                    # derivative if master will be or is published to
                    # -security. In case we have an error getting the
                    # status of the master security task, return (try
                    # again later)
                    tsk_st = { 'promote-to-security' : [ 'Confirmed', 'Fix Released' ] }

                    # If the master bug's tasks are not completely ready.
                    #
                    security_master = s.check_master_task(tbug, tsk_st)
                    if security_master < 0:
                        return

                    if s.security_publishing_required or security_master == 2:
                        s.verbose('Requires publishing to the -security pocket\n')
                        if s.wfb.tasks_by_name['promote-to-security'].status == 'New':
                            s.set_task_to_state('promote-to-security', 'Confirmed')
                    else:
                        if s.wfb.tasks_by_name['promote-to-security'].status == 'New':
                            s.set_task_to_state('promote-to-security', 'Invalid')

                    if s.wfb.tasks_by_name['promote-to-updates'].status == 'New':
                        s.set_task_to_state('promote-to-updates', 'Confirmed')
                        s.set_tagged_timestamp(task, 'kernel-stable-Promote-to-updates-start')
                        s.set_phase(task, 'CopyToUpdates')
                    # Now send a happy email 
                    msgbody = 'All tests are complete and the publishing tasks have been set to Confirmed\n'
                    #s.send_email(task, 'Package is ready for publication', msgbody)
                    #s.send_status_update(task, 'available for publication.')
                else:
                    s.verbose('Unable to set promote-to-{updates,security} ')
                    s.verbose('tasks. We are either near\nthe weekend, when ')
                    s.verbose('no publising is done, or this is a derivative ')
                    s.verbose('bug\nwhere the master bug isn\'t ready for ')
                    s.verbose('release or released yet\n')

            else:
                # don't have required testing signoffs
                s.verbose('ERROR: test completion tags not found during release test!\n')
                # Send email and possibly a status update
                msgbody = 'During the release test either the certification-testing-passed or the qa-testing-passed tag was not found\n'
                msgbody = msgbody + 'Tags on this bug are:\n'
                for ftag in s.bugtags:
                    msgbody = msgbody + '    ' + ftag + '\n'
                msgbody = msgbody + '\n'
                msgbody = msgbody + 'Further processing of this bug by Workflow Manager is halted.\n'
                s.send_comment(s.wfb.tasks_by_name[s.projectname], 'Test completion tags not found during release test', msgbody)
                # stop further processing by this bot
                s.set_task_to_state(s.projectname, 'Incomplete')
                s.set_phase(s.wfb.tasks_by_name[s.projectname], 'OnHold')
        # this method is not associated with a task state transition so no status returned
        return 

    def check_for_final_close(s, taskobj):
        """
        If either of the publishing tasks is set to complete (Fix Released) we
        make a check to see whether we can set the entire tracking bug to Fix Released (done)
        """
        s.verbose('*** Performing check for final close test\n')

        if s.wfb.tasks_by_name[s.projectname].status == 'Fix Released':
            print ' Bug already closed, aborting check'
            return False

        if (( s.wfb.tasks_by_name['promote-to-updates'].status == 'Fix Released') and
            (s.wfb.tasks_by_name['promote-to-security'].status == 'Invalid' or
            s.wfb.tasks_by_name['promote-to-security'].status == 'Fix Released')):

            # Check if packages were copied to the right pocket->component
            current_time = datetime.utcnow()
            pok_sec = True
            if s.wfb.tasks_by_name['promote-to-security'].status == 'Fix Released':
                pok_sec = s.check_component_in_pocket(taskobj,
                            'kernel-stable-Promote-to-updates-end',
                            'security')
            pok_upd = s.check_component_in_pocket(taskobj,
                        'kernel-stable-Promote-to-updates-end',
                        'updates')
            if not (pok_sec and pok_upd):
                return False

            print s.printlink,
            print ' Everything is done, setting bug to Fix Released'
            s.set_task_to_state(s.projectname, 'Fix Released')
            s.set_phase(taskobj, 'Released')

            # Send email and possibly a status update -spc- TODO
            msgbody = 'The package has been published and the bug is being set to Fix Released\n'
            s.send_comment(taskobj, 'Package Released!', msgbody)

            task = s.wfb.tasks_by_name['promote-to-updates']
            s.send_status_update(task, 'has been published.')

        # We should never trigger a release test from this, since it should have lready been done
        return False

    # initialize
    #
    def initialize(s):
        '''
        There are certain things (like connecting to LP) that I don't like to do
        in the constructor because they are so time consuming. Those thinngs are
        done here.
        '''
        s.defaults['launchpad_client_name'] = 'kernel-team-sru-workflow-manager'
        if s.args.staging:
            s.defaults['launchpad_services_root'] = 'qastaging'
        s.lp = LaunchpadService(s.defaults)
        s.ubuntu = Ubuntu()

        # The service.distributions property is a collection of distributions. We
        # pretty much only care about one, 'ubuntu'.
        #
        s.distro = s.lp.distributions['ubuntu']

        # Get set up for email and status messages
        if 'mail_notify' in s.cfg:
            mcfg = s.cfg['mail_notify']
            s.email = Email(mcfg['smtp_server'].encode('UTF-8'), mcfg['smtp_user'].encode('UTF-8'), mcfg['smtp_pass'].encode('UTF-8'))

        scfg = s.cfg['status_net']
        s.status = Status(scfg['url'], scfg['user'], scfg['pass'])

        # Get the text for spamming bugs
        spamtextpath =  path.join(path.dirname(__file__), s.cfg['bug_spam']['text_filename'])
        s.verbose('Bug spam text is from file %s\n' % spamtextpath)
        s.spamtext = open(spamtextpath, 'r').read()

        s.printlink = "(No link)"

        return

    # main
    #
    def main(s):
        '''
        This drives the overall process. It gets a list of the bugs that need to
        be worked (if not specified) and then runs through each of them.
        '''
        try:
            # Load our config options.
            #
            cfg_path = path.dirname(__file__) + '/sru-workflow.cfg'
            with open(cfg_path, 'r') as f:
                s.cfg = json.load(f)

            s.initialize()

            s.projects_tracked = [ 'kernel-development-workflow', 'kernel-sru-workflow' ]
            if s.args.bugs:
                for bugid in s.args.bugs:
                    s.shank(bugid, s.args.sauron)

            else:
                for project in s.projects_tracked:
                    info('Project: %s' % project)

                    for bugid in s.get_buglist(project):
                        s.shank(bugid, s.args.sauron)

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        return

    # end of main

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I do increadible things to kernel workflow bugs.
    '''
    app_epilog = '''
examples:
    sb
    sb --verbose
    sb --verbose --dry-run
    sb --verbose --staging
    sb --bugs=1134424,1133589
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--verbose', action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--dryrun', action='store_true',  default=False, help='Don\'t modify the bug(s). Should be used with --verbose.')
    parser.add_argument('--staging', action='store_true', default=False, help='Use the staging LP service instead of the production one.')
    parser.add_argument('--sauron',  action='store_true', default=False, help='I\'m a professional, I know what I\'m doing. (will work on bugs marked \'invalid\')')
    parser.add_argument('--bugs',                         default=None,  help='A comma seperated list of bug ids. Only these bug ids will be processed.')
    parser.add_argument('--logfile',                      default=None,  help='Where to log the output.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.verbose:
        basicConfig(filename=args.logfile, level=DEBUG, format=log_format)
    else:
        basicConfig(filename=args.logfile, level=INFO, format=log_format)

    if args.bugs:
        args.bugs = args.bugs.replace(' ', '')
        if ',' in args.bugs:
            args.bugs = args.bugs.split(',')
        else:
            args.bugs = [args.bugs]

    try:
        app = Shank(args)
        exit(app.main())
    except HTTPError, err:
        if err.code == 503:
            print 'Launchpad server is down (503)'
        else:
            print 'Launchpad returned error %d' % err.code
            raise

# vi:set ts=4 sw=4 expandtab:

