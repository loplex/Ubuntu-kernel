#!/usr/bin/env python
#

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, INFO, DEBUG, info, warning
from lpltk.LaunchpadService             import LaunchpadService
from ktl.check_component                import CheckComponent

# Checker
#
class Checker():

    # __init__
    #
    def __init__(s, args):
        info('Checker::__init__')
        s.args = args

    # initialize
    #
    def initialize(s):
        """
        A separate initialize that we can control when it gets called (not
        when the object is instantiated).
        """
        params = {}
        params['launchpad_client_name'] = 'kernel-team-check-component'
        params['read_only'] = True
        s.lp = LaunchpadService(params)
        return

    # doit
    #
    def doit(s):
        s.initialize()

        series = s.args.series
        package = s.args.src_pkg
        pocket = s.args.pocket
        if s.args.version:
            version = s.args.version
        else:
            version = None

        check_component = CheckComponent(s.lp)
        if s.args.show:
            clist = check_component.components_list(series, package, version, pocket)
            for item in clist:
                print("%s %s - in %s" % (item[0], item[1], item[2]))
        else:
            mlist = check_component.mismatches_list(series, package, version, pocket)
            for item in mlist:
                print("%s %s - is in %s instead of %s" % 
                      (item[0], item[1], item[2], item[3]))

# TheApp
#
class TheApp():
    '''
    This class is just the engine that makes everything go.
    '''

    # __init__
    #
    def __init__(s, args):
        '''
        '''
        s.args = args

    # main
    #
    def main(s):
        '''
        '''
        retval = 1

        try:
            retval = 0

            checker = Checker(s.args)
            checker.doit()

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            warning("Aborting ...")

        return retval

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I'm a application skeleton, your job is to make me into something useful.
    '''
    app_epilog = '''
examples:
    Checker --help
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)

    parser.add_argument('--verbose',      action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--list', '-l', dest='show', action='store_true', default=False, help='Print out all the individual components produced by the source package.')
    parser.add_argument('--pocket', '-p',       type=str,  default='proposed', help='Use the specified pocket instead of the default (proposed).')
    parser.add_argument('--version', '-v',      type=str,            help='Don\'t use the latest version from the archive, use this version.')
    parser.add_argument('series',     metavar='series',   type=str, nargs=1, help='The Ubuntu series that is to be used with the source package.')
    parser.add_argument('src_pkg',    metavar='package',  type=str, nargs=1, help='The source package whose components are to be checked.')

    args = parser.parse_args()
    args.series = args.series[0]
    args.src_pkg = args.src_pkg[0]

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.verbose:
        basicConfig(level=DEBUG, format=log_format)
    else:
        basicConfig(level=INFO, format=log_format)

    app = TheApp(args)
    exit(app.main())


# vi:set ts=4 sw=4 expandtab:

