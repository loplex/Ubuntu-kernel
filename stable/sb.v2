#!/usr/bin/env python
#

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import info, debug, error, warning, basicConfig, INFO, DEBUG, WARNING

from datetime                           import datetime
from lpltk.LaunchpadService             import LaunchpadService

from sb.package                         import Package, PackageError

# WorkflowBugTask
#
class WorkflowBugTask(object):
    # __init__
    #
    def __init__(s, lp_task, task_name):
        setattr(s, 'name', task_name)
        setattr(s, 'status', lp_task.status)
        setattr(s, 'importance', lp_task.importance)
        setattr(s, 'lp_task', lp_task)

        assignee    = lp_task.assignee
        if assignee is None:
            setattr(s, 'assignee', '*Unassigned')
        else:
            setattr(s, 'assignee', assignee.display_name)

# WorkflowBug
#
class WorkflowBug():
    # __init__
    #
    def __init__(s, lp, projects, bugid):
        s.lp = lp
        s.lpbug = s.lp.get_bug(bugid)
        s.projects = projects

        s.__package_name = None

        # If a bug isn't to be processed, detect this as early as possible.
        #
        s.is_valid = s.check_is_valid(s.lpbug)

        if s.is_valid:
            info('    Targeted Project:')
            info('        %s' % s.targeted_project)
            info('')
            s.properties = s.lpbug.properties
            if len(s.properties) > 0:
                info('    Properties:')
                for prop in s.properties:
                    info('        %s: %s' % (prop, s.properties[prop]))

            s.tasks_by_name = s.create_tasks_by_name()

    # check_is_valid
    #
    def check_is_valid(s, bug):
        '''
        '''
        retval = True
        for t in s.lpbug.tasks:
            task_name       = t.bug_target_name

            if task_name in s.projects:
                s.targeted_project = task_name
                if t.status == 'In Progress':
                    continue
                else:
                    info('        Not processing this bug because master task state is set to %s' % (t.status))
                    info('        Quitting this bug')
                    retval = False

        return retval

    # create_tasks_by_name
    #
    def create_tasks_by_name(s):
        '''
        We are only interested in the tasks that are specific to the workflow project. Others
        are ignored.
        '''
        taskbyname = {}

        info('')
        info('    Scanning bug tasks:')

        for t in s.lpbug.tasks:
            task_name       = t.bug_target_name

            if task_name.startswith(s.targeted_project):
                if '/' in task_name:
                    task_name = task_name[len(s.targeted_project)+1:].strip()
                taskbyname[task_name] = WorkflowBugTask(t, task_name)
            else:
                info('')
                info('        %-25s' % (task_name))
                info('            Action: Skipping non-workflow task')

        return taskbyname

# BS
#
class BS(object):
    '''
    Build Status
    '''
    # __init__
    #
    def __init__(s, status, package):
        '''
        0 - if the package-version wasn't found/published. In this case
            the package creator and assignee returned is always None
        1 - if the package-version is available (published), but still
            didn't finish building
        2 - package-version is available in the archive
        '''
        s.status = status
        s.package = package

    @property
    def is_built_and_published(s):
        return s.status == 2

class TaskActions(dict):
    # __init__
    #
    def __init__(s, d, *args):
        dict.__init__(s, *args)
        s.actions = {}
        for t in ['New', 'Incomplete', 'Opinion', 'Invalid', 'Won\'t Fix', 'Expired', 'Confirmed', 'Triaged', 'In Progress', 'Fix Committed', 'Fix Released', 'Unknown']:
            #s[t] = {}
            #s[t]['action'] = None
            s[t] = None

        for k in d:
            #s[k] = {}
            #s[k]['action'] = d[k]
            s[k] = d[k]

# Shankbot
#
class Shankbot():
    '''
    '''

    # __init__
    #
    def __init__(s, lp, lpserver, projects):
        s.lp = lp
        s.lpserver = lpserver
        s.projects = projects

        s.state_map = {
            'upload-to-ppa'             : TaskActions({}),
            'prepare-package'           : TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'prepare-package-lbm'       : TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'prepare-package-lrm'       : TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'prepare-package-lum'       : TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'prepare-package-meta'      : TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'prepare-package-ports-meta': TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'prepare-package-signed'    : TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'promote-to-proposed'       : TaskActions({'Fix Released' : s.promote_to_proposed_fix_released}),
            'verification-testing'      : TaskActions({'Fix Released' : s.verification_testing_fix_released}),
            'certification-testing'     : TaskActions({'Fix Released' : s.certification_testing_fix_released}),
            'regression-testing'        : TaskActions({'Fix Released' : s.regression_testing_fix_released}),
            'package-testing'           : TaskActions({'Fix Released' : s.package_testing_fix_released}),
            'promote-to-updates'        : TaskActions({'Fix Released' : s.check_for_final_close}),
            'promote-to-security'       : TaskActions({'Fix Released' : s.check_for_final_close}),
            'promote-to-release'        : TaskActions({'Fix Released' : s.promote_to_release_fix_released}),
            'security-signoff'          : TaskActions({'Invalid'      : s.security_signoff_finished,
                                                       'Fix Released' : s.security_signoff_finished}),
        }

    def security_signoff_finished(s, task):
        pass

    def promote_to_release_fix_released(s, task):
        pass

    def check_for_final_close(s, task):
        pass

    def package_testing_fix_released(s, task):
        pass

    def regression_testing_invalid(s, task):
        pass

    def certification_testing_fix_released(s, task):
        pass

    def certification_testing_invalid(s, task):
        pass

    def verification_testing_fix_released(s, task):
        pass

    def promote_to_proposed_fix_released(s, task):
        pass

    def prep_package_fix_released(s, task):
        pass

    def regression_testing_fix_released(s, task):
        pass

    # bug_url
    #
    def bug_url(s, bug_id):
        retval = 'https://%s/bugs/%s' % (s.lpserver, bug_id)
        return retval

    # process_bug_tasks
    #
    def process_bug_tasks(s, shankbug):
        info('')
        info('    Processing Workflow Tasks:')

        for workflow_task_name in sorted(shankbug.tasks_by_name):
            task = shankbug.tasks_by_name[workflow_task_name]
            info("        %-25s  %15s  %10s  %s" % (task.name, task.status, task.importance, task.assignee))

            if task.name not in s.state_map:
                info(s.printlink)
                info("            Warning: I don't know how to handle the task <%s>, skipping" % (task.name))
                continue

            action = s.state_map[task.name][task.status]

            if action is None:
                info('            Action: No action for task %s in state %s\n' % (task.name, task.status))

            else:
                res_action = action(task)
                #if s.projectname == 'kernel-sru-workflow' and res_action:
                #    performReleaseTest = True


    # shank
    #
    def shank(s, bugid):
        s.printlink =  '%s : (%s)' % (bugid, s.bug_url(bugid)),
        info('')
        info('Processing: %s' % s.printlink)

        bug = WorkflowBug(s.lp, s.projects, bugid)
        if bug.is_valid:
            try:
                p = Package(s.lp, bug)
                info('')
                if p.is_released:
                    info('        The package has been promoted to the approriate release directories. Nothing more to be done.')

                elif p.is_prepd:
                    info('        The package and all of it\'s dependents have been fully prepared.')

                else:
                    info('        Needs work')
                    p.determine_build_status(bug)

                s.process_bug_tasks(bug)

            except PackageError:
                pass

# TheApp
#
class TheApp():
    '''
    '''

    # __init__
    #
    def __init__(s, args):
        s.args = args

        lp_cfg = {}
        lp_cfg['launchpad_client_name'] = 'kernel-team-sru-workflow-manager'
        if s.args.staging:
            lp_cfg['launchpad_services_root'] = 'qastaging'
            s.lpserver = 'bugs.qastaging.launchpad.net'
        else:
            s.lpserver = 'bugs.launchpad.net'
        s.lp = LaunchpadService(lp_cfg)

    def get_buglist(s, project):
        retval = []

        search_tags            = [   # A list of the tags we care about
                'kernel-release-tracking-bug'
            ]
        search_tags_combinator = "All"
        search_status          = ["New", "In Progress", "Incomplete", "Fix Committed"] # A list of the bug statuses that we care about
        search_since           = datetime(year=2013, month=1, day=1)
        lp_project = s.lp.projects[project]
        tasks = lp_project.search_tasks(status=search_status, tags=search_tags, tags_combinator=search_tags_combinator, modified_since=search_since)

        for task in tasks:
            bug = task.bug
            info('found: %s' % bug.id)
            retval.append(bug.id)

        return retval

    # main
    #
    def main(s):
        retval = 1
        try:
            debug('Starting ...')

            projects_tracked = [ 'kernel-development-workflow', 'kernel-sru-workflow' ]
            bot = Shankbot(s.lp, s.lpserver, projects_tracked)
            if s.args.bugs:
                for bug in s.args.bugs:
                    bot.shank(bug)

            else:
                for project in projects_tracked:
                    info('Project: %s' % project)

                    for bug in s.get_buglist(project):
                        bot.shank(bug)

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            error("Aborting ...")

        if retval > 0:
            error("")
            error("Due to the above error(s), this script is unable to continue and is terminating.")
            error("")

        debug('That\'s All Folks!')
        return retval

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I do increadible things to kernel workflow bugs.
    '''
    app_epilog = '''
examples:
    sb
    sb --verbose
    sb --verbose --dry-run
    sb --verbose --staging
    sb --bugs=1134424,1133589
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--verbose', action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--dry-run', action='store_true', default=False, help='Don\'t modify the bug(s). Should be used with --verbose.')
    parser.add_argument('--staging', action='store_true', default=False, help='Use the staging LP service instead of the production one.')
    parser.add_argument('--bugs',                         default=None,  help='A comma seperated list of bug ids. Only these bug ids will be processed.')
    parser.add_argument('--log-file',                     default=None,  help='Where to log the output.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.verbose:
        basicConfig(filename=args.log_file, level=DEBUG, format=log_format)
    else:
        basicConfig(filename=args.log_file, level=INFO, format=log_format)

    if args.bugs:
        args.bugs = args.bugs.replace(' ', '')
        if ',' in args.bugs:
            args.bugs = args.bugs.split(',')
        else:
            args.bugs = [args.bugs]

    app = TheApp(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab syntax=python:
