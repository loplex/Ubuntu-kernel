#!/usr/bin/env python
#

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import info, debug, error, warning, basicConfig, INFO, DEBUG, WARNING
import re

from datetime                           import datetime
from lpltk.LaunchpadService             import LaunchpadService

from ktl.bugs                           import DeltaTime
from ktl.ubuntu                         import Ubuntu

# ErrorExit
#
class ErrorExit(Exception):
    """
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    """
    def __init__(self, emsg):
        self.__message = emsg

    @property
    def message(self):
        '''
        The shell command that was being executed when the timeout occured.
        '''
        return self.__message

class PackageInfo():
    def __init__(s, txt):
        matched = False
        #                              .- package name (group(1))
        #                             /           .- kernel version (group(2))
        #                            /           /          .- version/abi separator (group(3))
        #                           /           /          /
        ver_rc     = re.compile("(\S+): (\d+\.\d+\.\d+)([-\.])(\d+)\.(\d+)([~a-z\d]*)")
        #                                                       /      /       /
        #                                                      /      /       .- backport extra (m.group(6))
        #                                                     /      .- upload number (m.group(5))
        #                                                    .- abi (group(4))

        #info('     Extract package info\n')
        setattr(s, 'valid', False)
        m = ver_rc.search(txt)
        if m is not None:
            matched = True
            #info('         package: %s\n' % m.group(1))
            #info('         version: %s%s%s.%s%s\n' % (m.group(2), m.group(3), m.group(4), m.group(5), m.group(6)))
            #info('          kernel: %s\n' % m.group(2))
            #info('             abi: %s\n' % m.group(4))

            setattr(s, 'name', m.group(1))
            setattr(s, 'version', '%s%s%s.%s%s' % (m.group(2), m.group(3), m.group(4), m.group(5), m.group(6)))
            setattr(s, 'kernel', m.group(2))
            setattr(s, 'abi', m.group(4))
            s.valid = True

        if not matched:
            warning(' ** None of the regular expressions matched the title (%s)\n' % txt)

# WorkflowBug
#
class WorkflowBug():
    # __init__
    #
    def __init__(s, lp, projects, bugid):
        s.lp = lp
        s.bug = s.lp.get_bug(bugid)
        s.projects = projects

        s.__package_name = None

        # If a bug isn't to be processed, detect this as early as possible.
        #
        s.is_valid = s.check_is_valid(s.bug)

        if s.is_valid:
            info('    Targeted Project:')
            info('        %s' % s.targeted_project)
            info('')
            s.properties = s.bug.properties
            if len(s.properties) > 0:
                info('    Properties:')
                for prop in s.properties:
                    info('        %s: %s' % (prop, s.properties[prop]))

            s.tasks_by_name = s.create_tasks_by_name()

    # check_is_valid
    #
    def check_is_valid(s, bug):
        '''
        '''
        retval = True
        for t in s.bug.tasks:
            task_name       = t.bug_target_name

            if task_name in s.projects:
                s.targeted_project = task_name
                if t.status == 'In Progress':
                    continue
                else:
                    info('        Not processing this bug because master task state is set to %s' % (t.status))
                    info('        Quitting this bug')
                    retval = False

        return retval

    # create_tasks_by_name
    #
    def create_tasks_by_name(s):
        '''
        We are only interested in the tasks that are specific to the workflow project. Others
        are ignored.
        '''
        taskbyname = {}

        info('')
        info('    Scanning bug tasks:')

        for t in s.bug.tasks:
            task_name       = t.bug_target_name

            if task_name.startswith(s.targeted_project):
                if '/' in task_name:
                    task_name = task_name[len(s.targeted_project)+1:].strip()
                taskbyname[task_name] = t
            else:
                info('')
                info('        %-25s' % (task_name))
                info('            Action: Skipping non-workflow task')

        return taskbyname

# Package
#
class Package():

    # __init__
    #
    def __init__(s, lp):
        s.ubuntu = Ubuntu()
        s.lp = lp
        s.__distro_series = None
        s.__is_new_abi = None

    # distro_series
    #
    @property
    def distro_series(s):
        if s.__distro_series is None:
            series = s.ubuntu.series_name(s.package.name, s.package.version)
            if series:
                sc = s.lp.launchpad.distributions["ubuntu"].series_collection
                for ds in sc:
                    if ds.name == series:
                        s.__distro_series = ds
                        warning(s.__distro_series)
                        break

            if s.__distro_series is None:
                emsg = "        ERROR: can't figure out the distro series for %s-%s\n" % (s.package.name, s.package.version)
                error(emsg)
                raise ErrorExit(emsg)

        return s.__distro_series

    # is_new_abi
    #
    @property
    def is_new_abi(s):
        if s.__is_new_abi is None:
            '''
            Try to determine if there was an abi change in this release. We
            guess this by looking if there is already a package with same
            abi in the updates/release pocket.
            '''
            retval = True
            main_archive = s.lp.launchpad.distributions["ubuntu"].main_archive
            if s.package.kernel and s.package.abi:
                st_abi_rel, _ = s.build_status(s.distro_series, s.package.name, s.package.abi, main_archive, s.package.kernel, 'Release')
                st_abi_upd, _ = s.build_status(s.distro_series, s.package.name, s.package.abi, main_archive, s.package.kernel, 'Updates')
                if st_abi_rel == 2 or st_abi_upd == 2:
                    s.__is_new_abi = False

        return s.__is_new_abi

    # check
    #
    def check(s, shankbug):
        """
        Verify the required packages for this update, and determine its
        build status
        """
        bug = shankbug.bug

        # Determine some properties of the package we are looking at based on the
        # bug title. This information is used further on.
        #
        package = PackageInfo(bug.title)
        s.package = PackageInfo(bug.title)
        if not s.package.valid:
            warning('        Unable to check package builds for this bug: either the package name or')
            warning('        the version are not properly indicated in the bug title.\n')
            return

        #--
        pkgs = {}
        series = s.ubuntu.series_name(package.name, package.version)
        entry = s.ubuntu.lookup(series)
        if entry:
            if 'dependent-packages' in entry:
                if package.name in entry['dependent-packages']:
                    pkgs.update(entry['dependent-packages'][package.name])
        pkgs['main'] = package.name

        # Check build status. This is really convoluted... due to number
        # of tasks and we wanting the better behaviour as possible
        promoted_to_updates = True
        promoted_to_security = True
        promoted_to_release = True
        pkg_security = None
        pkg_updates = None
        pkg_release = None
        task_status = [ 'New', 'In Progress', 'Fix Released' ]
        ckt = s.lp.launchpad.people['canonical-kernel-team']
        ckt_archive = ckt.getPPAByName(name='ppa')
        for dep in iter(pkgs):
            if pkgs[dep] == package.name:
                bug_task = 'prepare-package'
            else:
                bug_task = 'prepare-package-%s' % (dep)
            abi_num = None
            pkg_rel = package.version
            if dep in [ 'lbm', 'lrm', 'lum', 'meta', 'ports-meta' ] and package.abi:
                abi_num = package.abi
                pkg_rel = package.kernel
            status_updates = 0
            status_release = 0
            prepare_status = 0
            prepare_assignee = None
            prepare_uploader = None
            if shankbug.targeted_project == 'kernel-sru-workflow':
                promoted_to_release = False
                main_archive = s.lp.launchpad.distributions["ubuntu"].main_archive
                status_ckt,      pkg_ckt      = s.build_status(s.distro_series, pkgs[dep], abi_num, ckt_archive,  pkg_rel)
                status_proposed, pkg_proposed = s.build_status(s.distro_series, pkgs[dep], abi_num, main_archive, pkg_rel, 'Proposed')
                status_updates,  pkg_updates  = s.build_status(s.distro_series, pkgs[dep], abi_num, main_archive, pkg_rel, 'Updates')
                status_security, pkg_security = s.build_status(s.distro_series, pkgs[dep], abi_num, main_archive, pkg_rel, 'Security')
                if status_security != 2:
                    promoted_to_security = False
                if status_updates != 2:
                    promoted_to_updates = False
                for s in [ status_ckt, status_proposed, status_updates ]:
                    if s > prepare_status:
                        prepare_status = s
                for c in [ pkg_ckt, pkg_proposed, pkg_updates, pkg_security ]:
                    if c:
                        prepare_assignee = c.package_creator
                        prepare_uploader = c.package_signer
                        break
            else:
                promoted_to_updates = False
                promoted_to_security = False
                status_proposed, pkg_proposed = s.build_status(s.distro_series, pkgs[dep], abi_num, main_archive, pkg_rel, 'Proposed')
                status_release,  pkg_release  = s.build_status(s.distro_series, pkgs[dep], abi_num, main_archive, pkg_rel, 'Release')
                if status_release != 2:
                    promoted_to_release = False
                prepare_status = status_proposed
                if status_release > prepare_status:
                    prepare_status = status_release
                if pkg_proposed:
                    prepare_assignee = pkg_proposed.package_creator
                    prepare_uploader = pkg_proposed.package_signer
                elif pkg_release:
                    prepare_assignee = pkg_release.package_creator
                    prepare_uploader = pkg_release.package_signer

            ###################################################################
            #
            return

            # When things are moved from one pocket to another, things
            # may be unavailable for some time, and we may think no
            # packages were built. Thus we add a tagged timestamp,
            # marking the time when we detect that the builds are
            # missing. If after 1 hour the builds are still unavailable,
            # then we allow to reset the tasks.
            prop = 'kernel-%s-build-unavailable' % (dep)
            if (s.taskbyname[bug_task].status == 'Fix Released' and
                prepare_status != 2):
                s.set_tagged_timestamp(s.taskbyname[bug_task], prop)
                if not prop in s.bug.properties:
                    continue
                date_str = s.bug.properties[prop]
                timestamp = datetime.strptime(date_str, '%A, %d. %B %Y %H:%M UTC')
                delta = DeltaTime(timestamp, datetime.utcnow())
                if delta.hours < 1:
                    info('        Builds gone for %s, waiting 1 hour to reset tasks' % (bug_task))
                    continue
            if prop in s.bug.properties:
                s.props.set({prop:None})
            new_status = s.taskbyname[bug_task].status
            if abi_num:
                if s.is_new_abi:
                    new_status = task_status[prepare_status]
                else:
                    if new_status != 'Invalid' and new_status != 'Fix Released':
                        new_status = 'Invalid'
            else:
                new_status = task_status[prepare_status]
            if prepare_assignee and new_status != 'Invalid':
                s.set_task_assignee(bug_task, prepare_assignee)
            s.set_task_to_state(bug_task, new_status)
            # Take care of the upload-to-ppa task if needed
            if dep == 'main' and 'upload-to-ppa' in s.taskbyname:
                if prepare_uploader:
                    s.set_task_assignee('upload-to-ppa', prepare_uploader)
                if prepare_status >= 1:
                    s.set_task_to_state('upload-to-ppa', 'Fix Released')
                elif s.taskbyname['upload-to-ppa'].status != 'Confirmed':
                    s.set_task_to_state('upload-to-ppa', 'New')

        ###################################################################
        #
        return

        # Set promotion bug tasks
        if promoted_to_security:
            if pkg_security:
                s.set_task_assignee('promote-to-security',
                                       pkg_security.creator)
            s.set_task_to_state('promote-to-security', 'Fix Released')
        #else:
            # TODO: verify promote-to-security task state
        if promoted_to_updates:
            if pkg_updates:
                s.set_task_assignee('promote-to-updates',
                                       pkg_updates.creator)
            s.set_task_to_state('promote-to-updates', 'Fix Released')
        #else:
            # TODO: verify promote-to-updates task state
        if promoted_to_release:
            if pkg_release:
                s.set_task_assignee('promote-to-release',
                                       pkg_release.creator)
            s.set_task_to_state('promote-to-release', 'Fix Released')
        #else:
            # TODO: verify promote-to-updates task state


    def get_sources(s, archive, package, release=None, pocket=''):
        if release is not None:
            if pocket != '':
                ps = archive.getPublishedSources(distro_series=s.distro_series, exact_match=True, source_name=package, status='Published', version=release, pocket=pocket)
                error('get_sources #1')
            else:
                ps = archive.getPublishedSources(distro_series=s.distro_series, exact_match=True, source_name=package, status='Published', version=release)
                error('get_sources #2')
        else:
            if pocket != '':
                ps = archive.getPublishedSources(distro_series=s.distro_series, exact_match=True, source_name=package, status='Published', pocket=pocket)
                error('get_sources #3')
            else:
                ps = archive.getPublishedSources(distro_series=s.distro_series, exact_match=True, source_name=package, status='Published')
                error('get_sources #4')
        return ps

    def build_status(s, series, package, abi, archive, release=None, pocket=''):
        """
        Return an status code, the possible assignee responsible and the
        package creator related to the publishing of the package in the
        given archive on the optionally specified pocket (if we want the
        check to be restricted on a specific pocket). The following
        values are returned as the status code:
        0 - if the package-version wasn't found/published. In this case
            the package creator and assignee returned is always None
        1 - if the package-version is available (published), but still
            didn't finish building
        2 - package-version is available in the archive

        The parameters are:
          series    - the distribution series (quantal, oneiric, etc.)
          package   - the package name
          release   - the version or version-abi number to match
          abi_match - if provided, indicates that release is not an exact
                      version number, and we must do an ABI check
          archive   - launchpad archive to look into
          pocket    - optional, if we want only results of the archive from
                      the specified pocket
        """

        error('build_status - archive: %s; package: %s; release: %s; pocket: %s' % (archive, package, release, pocket))
        #ps = s.get_sources(archive, package, release, pocket)
        #if not abi:
        #    ps = s.get_sources(archive, package, release, pocket)
        if pocket and not abi:
            error('build_status #1')
            ps = s.get_sources(archive, package, release, pocket)
        elif not pocket and not abi:
            error('build_status #2')
            ps = s.get_sources(archive, package, release)
        elif pocket and abi:
            error('build_status #3')
            ps = s.get_sources(archive, package, pocket=pocket)
        else:
            error('build_status #4')
            ps = s.get_sources(archive, package)
        matches = []
        if abi:
            dep_ver1 = '%s-%s' % (release, abi)
            dep_ver2 = '%s.%s' % (release, abi)
            rel_match = '<%s> or <%s>' % (dep_ver1, dep_ver2)
            for p in ps:
                src_ver = p.source_package_version
                # special case for hardy lrm version...
                if ((series.name == 'hardy') and
                    (package == 'linux-restricted-modules-2.6.24')):
                    if src_ver.startswith('2.6.24'):
                        ver_split = src_ver.split('-', 1)
                        if len(ver_split) > 1:
                            src_ver = '2.6.24-%s' % (ver_split[1])
                if ((src_ver.startswith(dep_ver1 + '.') or src_ver.startswith(dep_ver2 + '.'))):
                    matches.append(p)
            if not matches:
                info('        Can\'t find <%s> (%s) build on %s (pocket:%s)' % (package, rel_match, archive.displayname, pocket))
                return 0, None
        else:
            rel_match = '<%s>' % (release)
            for p in ps:
                matches.append(p)
            if not matches:
                info('        Can\'t find <%s> %s build on %s (pocket:%s)' % (package, rel_match, archive.displayname, pocket))
                return 0, None
        res = 0, None
        lst_date = None
        for pkg in matches:
            src_id = str(pkg.self).rsplit('/', 1)[1]
            build_summaries = archive.getBuildSummariesForSourceIds(source_ids=[src_id])[src_id]
            if build_summaries['status'] == 'FULLYBUILT':
                info('        <%s> %s built (pocket:%s)' % (package, rel_match, pocket))
                bs = 2
            else:
                info('        <%s> %s not fully built yet, skipping (pocket:%s)' % (package, rel_match, pocket))
                bs = 1
            # prefer newer published items...
            if lst_date:
                if lst_date > pkg.date_published:
                    continue
            lst_date = pkg.date_published
            res = bs, pkg
        return res

# Shankbot
#
class Shankbot():
    '''
    '''

    # __init__
    #
    def __init__(s, lp, lpserver, projects):
        s.lp = lp
        s.lpserver = lpserver
        s.projects = projects

    # bug_url
    #
    def bug_url(s, bug_id):
        retval = 'https://%s/bugs/%s' % (s.lpserver, bug_id)
        return retval

    # shank
    #
    def shank(s, bugid):
        s.printlink =  '%s : (%s)' % (bugid, s.bug_url(bugid)),
        info('')
        info('Processing: %s' % s.printlink)

        bug = WorkflowBug(s.lp, s.projects, bugid)
        if bug.is_valid:
            p = Package(s.lp)
            p.check(bug)

# TheApp
#
class TheApp():
    '''
    '''

    # __init__
    #
    def __init__(s, args):
        s.args = args

        lp_cfg = {}
        lp_cfg['launchpad_client_name'] = 'kernel-team-sru-workflow-manager'
        if s.args.staging:
            lp_cfg['launchpad_services_root'] = 'qastaging'
            s.lpserver = 'bugs.qastaging.launchpad.net'
        else:
            s.lpserver = 'bugs.launchpad.net'
        s.lp = LaunchpadService(lp_cfg)

    def get_buglist(s, project):
        retval = []

        search_tags            = [   # A list of the tags we care about
                'kernel-release-tracking-bug'
            ]
        search_tags_combinator = "All"
        search_status          = ["New", "In Progress", "Incomplete", "Fix Committed"] # A list of the bug statuses that we care about
        search_since           = datetime(year=2013, month=1, day=1)
        lp_project = s.lp.projects[project]
        tasks = lp_project.search_tasks(status=search_status, tags=search_tags, tags_combinator=search_tags_combinator, modified_since=search_since)

        for task in tasks:
            bug = task.bug
            info('found: %s' % bug.id)
            retval.append(bug.id)

        return retval

    # main
    #
    def main(s):
        retval = 1
        try:
            debug('Starting ...')

            projects_tracked = [ 'kernel-development-workflow', 'kernel-sru-workflow' ]
            bot = Shankbot(s.lp, s.lpserver, projects_tracked)
            if s.args.bugs:
                for bug in s.args.bugs:
                    bot.shank(bug)

            else:
                for project in projects_tracked:
                    info('Project: %s' % project)

                    for bug in s.get_buglist(project):
                        bot.shank(bug)

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            error("Aborting ...")

        if retval > 0:
            error("")
            error("Due to the above error(s), this script is unable to continue and is terminating.")
            error("")

        debug('That\'s All Folks!')
        return retval

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I do increadible things to kernel workflow bugs.
    '''
    app_epilog = '''
examples:
    sb
    sb --verbose
    sb --verbose --dry-run
    sb --verbose --staging
    sb --bugs=1134424,1133589
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--verbose', action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--dry-run', action='store_true', default=False, help='Don\'t modify the bug(s). Should be used with --verbose.')
    parser.add_argument('--staging', action='store_true', default=False, help='Use the staging LP service instead of the production one.')
    parser.add_argument('--bugs',                         default=None,  help='A comma seperated list of bug ids. Only these bug ids will be processed.')
    parser.add_argument('--log-file',                     default=None,  help='Where to log the output.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.verbose:
        basicConfig(filename=args.log_file, level=DEBUG, format=log_format)
    else:
        basicConfig(filename=args.log_file, level=INFO, format=log_format)

    if args.bugs:
        args.bugs = args.bugs.replace(' ', '')
        if ',' in args.bugs:
            args.bugs = args.bugs.split(',')
        else:
            args.bugs = [args.bugs]

    app = TheApp(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab syntax=python:
