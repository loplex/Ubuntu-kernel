#!/usr/bin/env python
#

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import info, debug, error, warning, basicConfig, INFO, DEBUG, WARNING

from datetime                           import datetime
from lpltk.LaunchpadService             import LaunchpadService

from sb.package                         import Package, PackageError

# Task handlers
#
from sb.th.prep_package                 import PrepPackage
from sb.th.promote_to_proposed          import PromoteToProposed
from sb.th.verification_testing         import VerificationTesting
from sb.th.certification_testing        import CertificationTesting
from sb.th.regression_testing           import RegressionTesting
from sb.th.package_testing              import PackageTesting
from sb.th.closer                       import Closer
from sb.th.promote_to_release           import PromoteToRelease
from sb.th.security_signoff             import SecuritySignoff


# WorkflowBugTask
#
class WorkflowBugTask(object):
    # __init__
    #
    def __init__(s, lp_task, task_name):
        setattr(s, 'name', task_name)
        setattr(s, 'status', lp_task.status)
        setattr(s, 'importance', lp_task.importance)
        setattr(s, 'lp_task', lp_task)

        assignee    = lp_task.assignee
        if assignee is None:
            setattr(s, 'assignee', '*Unassigned')
        else:
            setattr(s, 'assignee', assignee.display_name)

# WorkflowBug
#
class WorkflowBug():
    # __init__
    #
    def __init__(s, lp, projects, bugid, sauron=False):
        s.lp = lp
        s.lpbug = s.lp.get_bug(bugid)
        s.projects = projects
        s.sauron = sauron

        s.__package_name = None

        # If a bug isn't to be processed, detect this as early as possible.
        #
        s.is_valid = s.check_is_valid(s.lpbug)

        if s.is_valid:
            info('    Targeted Project:')
            info('        %s' % s.targeted_project)
            info('')
            s.properties = s.lpbug.properties
            if len(s.properties) > 0:
                info('    Properties:')
                for prop in s.properties:
                    info('        %s: %s' % (prop, s.properties[prop]))

            s.tasks_by_name = s.create_tasks_by_name()

    # check_is_valid
    #
    def check_is_valid(s, bug):
        '''
        Determine if this bug is one that we wan't to be processing.
        '''
        retval = True
        for t in s.lpbug.tasks:
            task_name       = t.bug_target_name

            if task_name in s.projects:
                s.targeted_project = task_name
                if t.status == 'In Progress':
                    continue
                else:
                    if s.sauron:
                        continue
                    info('        Not processing this bug because master task state is set to %s' % (t.status))
                    info('        Quitting this bug')
                    retval = False

        return retval

    # create_tasks_by_name
    #
    def create_tasks_by_name(s):
        '''
        We are only interested in the tasks that are specific to the workflow project. Others
        are ignored.
        '''
        taskbyname = {}

        info('')
        info('    Scanning bug tasks:')

        for t in s.lpbug.tasks:
            task_name       = t.bug_target_name

            if task_name.startswith(s.targeted_project):
                if '/' in task_name:
                    task_name = task_name[len(s.targeted_project)+1:].strip()
                taskbyname[task_name] = WorkflowBugTask(t, task_name)
            else:
                info('')
                info('        %-25s' % (task_name))
                info('            Action: Skipping non-workflow task')

        return taskbyname

# TaskActions
#
class TaskActions(dict):
    '''
    For every workflow task there is one or more action(s) that are to
    be perfomed on it. The action the be performed depends on the current
    state (status) of that task.

    This class (a dictionary) helps building the master dictionary of
    tasks and actions.
    '''
    # __init__
    #
    def __init__(s, d, *args):
        dict.__init__(s, *args)
        s.actions = {}
        for t in ['New', 'Incomplete', 'Opinion', 'Invalid', 'Won\'t Fix', 'Expired', 'Confirmed', 'Triaged', 'In Progress', 'Fix Committed', 'Fix Released', 'Unknown']:
            s[t] = None

        for k in d:
            s[k] = d[k]

# Shankbot
#
class Shankbot():
    '''
    '''

    # __init__
    #
    def __init__(s, lp, lpserver, projects):
        s.lp = lp
        s.lpserver = lpserver
        s.projects = projects

        s.sm = { # sm - State Mapping
            'upload-to-ppa'             : TaskActions({}),
            'prepare-package'           : TaskActions({'Fix Released' : PrepPackage}),
            'prepare-package-lbm'       : TaskActions({'Fix Released' : PrepPackage}),
            'prepare-package-lrm'       : TaskActions({'Fix Released' : PrepPackage}),
            'prepare-package-lum'       : TaskActions({'Fix Released' : PrepPackage}),
            'prepare-package-meta'      : TaskActions({'Fix Released' : PrepPackage}),
            'prepare-package-ports-meta': TaskActions({'Fix Released' : PrepPackage}),
            'prepare-package-signed'    : TaskActions({'Fix Released' : PrepPackage}),
            'promote-to-proposed'       : TaskActions({'Fix Released' : PromoteToProposed}),
            'verification-testing'      : TaskActions({'Fix Released' : VerificationTesting}),
            'certification-testing'     : TaskActions({'Fix Released' : CertificationTesting}),
            'regression-testing'        : TaskActions({'Fix Released' : RegressionTesting}),
            'package-testing'           : TaskActions({'Fix Released' : PackageTesting}),
            'promote-to-updates'        : TaskActions({'Fix Released' : Closer}),
            'promote-to-security'       : TaskActions({'Fix Released' : Closer}),
            'promote-to-release'        : TaskActions({'Fix Released' : PromoteToRelease}),
            'security-signoff'          : TaskActions({'Invalid'      : SecuritySignoff, 'Fix Released' : SecuritySignoff}),
        }

    # bug_url
    #
    def bug_url(s, bug_id):
        retval = 'https://%s/bugs/%s' % (s.lpserver, bug_id)
        return retval

    # process_bug_tasks
    #
    def process_bug_tasks(s, shankbug):
        '''
        Go through every workflow task and perform the associated actions
        based on the current state (status) of that task.
        '''

        info('')
        info('    Processing Workflow Tasks:')

        for workflow_task_name in sorted(shankbug.tasks_by_name):
            if workflow_task_name in ['kernel-sru-workflow', 'kernel-development-workflow']:
                continue

            task = shankbug.tasks_by_name[workflow_task_name]
            info("        %-25s  %15s  %10s  %s" % (task.name, task.status, task.importance, task.assignee))

            if workflow_task_name not in s.sm:
                info('            ' + s.printlink)
                info('            Warning: I don\'t know how to handle the task <%s>, skipping' % (workflow_task_name))
                continue

            handler = s.sm[workflow_task_name][task.status]

            if handler is None:
                info('            Action: No action for task %s in state %s' % (workflow_task_name, task.status))

            else:
                h = handler(shankbug.targeted_project, task)
                if h.preconditions_met:
                    h.action()

                #if s.projectname == 'kernel-sru-workflow' and res_action:
                #    performReleaseTest = True

            info('')


    # shank
    #
    def shank(s, bugid, sauron):
        s.printlink =  '%s : (%s)' % (bugid, s.bug_url(bugid)),
        info('')
        info('Processing: %s' % s.printlink)

        bug = WorkflowBug(s.lp, s.projects, bugid, sauron)
        if bug.is_valid:
            try:
                p = Package(s.lp, bug)
                info('')
                if p.is_released:
                    info('        The package has been promoted to the approriate release directories. Nothing more to be done.')

                elif p.is_prepd:
                    info('        The package and all of it\'s dependents have been fully prepared.')

                else:
                    info('        Needs work')
                    p.determine_build_status(bug)

                s.process_bug_tasks(bug)

            except PackageError:
                pass

# TheApp
#
class TheApp():
    '''
    This class is just the engine that makes everything go. It either goes through each
    bug specified on the command line or it searches Launchpad for the bugs that it
    needs to work on and then cranks through them.
    '''

    # __init__
    #
    def __init__(s, args):
        '''
        When instantiated, we go ahead and make our initial connection to Launchpad and
        get signed in.
        '''
        s.args = args

        lp_cfg = {}
        lp_cfg['launchpad_client_name'] = 'kernel-team-sru-workflow-manager'
        if s.args.staging:
            lp_cfg['launchpad_services_root'] = 'qastaging'
            s.lpserver = 'bugs.qastaging.launchpad.net'
        else:
            s.lpserver = 'bugs.launchpad.net'
        s.lp = LaunchpadService(lp_cfg)

    # get_buglist
    #
    def get_buglist(s, project):
        '''
        Perform a search of Launchpad to get a list of all the bugs that match
        our criteria.

        A list of the bug ids is returned.
        '''
        retval = []

        search_tags            = [   # A list of the tags we care about
                'kernel-release-tracking-bug'
            ]
        search_tags_combinator = "All"
        search_status          = ["New", "In Progress", "Incomplete", "Fix Committed"] # A list of the bug statuses that we care about
        search_since           = datetime(year=2013, month=1, day=1)
        lp_project = s.lp.projects[project]
        tasks = lp_project.search_tasks(status=search_status, tags=search_tags, tags_combinator=search_tags_combinator, modified_since=search_since)

        for task in tasks:
            bug = task.bug
            info('found: %s' % bug.id)
            retval.append(bug.id)

        return retval

    # main
    #
    def main(s):
        retval = 1
        try:
            debug('Starting ...')

            projects_tracked = [ 'kernel-development-workflow', 'kernel-sru-workflow' ]
            bot = Shankbot(s.lp, s.lpserver, projects_tracked)
            if s.args.bugs:
                for bug in s.args.bugs:
                    bot.shank(bug, s.args.sauron)

            else:
                for project in projects_tracked:
                    info('Project: %s' % project)

                    for bug in s.get_buglist(project):
                        bot.shank(bug, s.args.sauron)

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            error("Aborting ...")

        if retval > 0:
            error("")
            error("Due to the above error(s), this script is unable to continue and is terminating.")
            error("")

        debug('That\'s All Folks!')
        return retval

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I do increadible things to kernel workflow bugs.
    '''
    app_epilog = '''
examples:
    sb
    sb --verbose
    sb --verbose --dry-run
    sb --verbose --staging
    sb --bugs=1134424,1133589
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--verbose', action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--dry-run', action='store_true', default=False, help='Don\'t modify the bug(s). Should be used with --verbose.')
    parser.add_argument('--staging', action='store_true', default=False, help='Use the staging LP service instead of the production one.')
    parser.add_argument('--sauron',  action='store_true', default=False, help='I\'m a professional, I know what I\'m doing. (will work on bugs marked \'invalid\')')
    parser.add_argument('--bugs',                         default=None,  help='A comma seperated list of bug ids. Only these bug ids will be processed.')
    parser.add_argument('--logfile',                      default=None,  help='Where to log the output.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.verbose:
        basicConfig(filename=args.logfile, level=DEBUG, format=log_format)
    else:
        basicConfig(filename=args.logfile, level=INFO, format=log_format)

    if args.bugs:
        args.bugs = args.bugs.replace(' ', '')
        if ',' in args.bugs:
            args.bugs = args.bugs.split(',')
        else:
            args.bugs = [args.bugs]

    app = TheApp(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab syntax=python:
