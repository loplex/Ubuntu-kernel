#!/usr/bin/env python
#

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import info, debug, error, warning, basicConfig, INFO, DEBUG, WARNING
import re

from datetime                           import datetime
from lpltk.LaunchpadService             import LaunchpadService

from ktl.bugs                           import DeltaTime
from ktl.ubuntu                         import Ubuntu

# GeneralError
#
class GeneralError(Exception):
    '''
    Generic base class for my exceptions.
    '''
    def __init__(s, emsg):
        s.__message = emsg

    @property
    def message(s):
        '''
        The shell command that was being executed when the timeout occured.
        '''
        return s.__message

# ErrorExit
#
class ErrorExit(GeneralError):
    '''
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    '''
    def __init__(s, emsg):
        GeneralError(emsg)

# ErrorExit
#
class PackageError(GeneralError):
    '''
    Thrown when some basic information about the package that is associated with the
    shankbug could not be determined.
    '''
    def __init__(s, emsg):
        GeneralError(emsg)

class PackageInfo():
    def __init__(s, txt):
        matched = False
        #                              .- package name (group(1))
        #                             /           .- kernel version (group(2))
        #                            /           /          .- version/abi separator (group(3))
        #                           /           /          /
        ver_rc     = re.compile("(\S+): (\d+\.\d+\.\d+)([-\.])(\d+)\.(\d+)([~a-z\d]*)")
        #                                                       /      /       /
        #                                                      /      /       .- backport extra (m.group(6))
        #                                                     /      .- upload number (m.group(5))
        #                                                    .- abi (group(4))

        #info('     Extract package info\n')
        setattr(s, 'valid', False)
        m = ver_rc.search(txt)
        if m is not None:
            matched = True
            #info('         package: %s\n' % m.group(1))
            #info('         version: %s%s%s.%s%s\n' % (m.group(2), m.group(3), m.group(4), m.group(5), m.group(6)))
            #info('          kernel: %s\n' % m.group(2))
            #info('             abi: %s\n' % m.group(4))

            setattr(s, 'name', m.group(1))
            setattr(s, 'version', '%s%s%s.%s%s' % (m.group(2), m.group(3), m.group(4), m.group(5), m.group(6)))
            setattr(s, 'kernel', m.group(2))
            setattr(s, 'abi', m.group(4))
            s.valid = True

        if not matched:
            warning(' ** None of the regular expressions matched the title (%s)' % txt)

# WorkflowBugTask
#
class WorkflowBugTask(object):
    # __init__
    #
    def __init__(s, lp_task, task_name):
        setattr(s, 'name', task_name)
        setattr(s, 'status', lp_task.status)
        setattr(s, 'importance', lp_task.importance)

        assignee    = lp_task.assignee
        if assignee is None:
            setattr(s, 'assignee', '*Unassigned')
        else:
            setattr(s, 'assignee', assignee.display_name)

# WorkflowBug
#
class WorkflowBug():
    # __init__
    #
    def __init__(s, lp, projects, bugid):
        s.lp = lp
        s.lpbug = s.lp.get_bug(bugid)
        s.projects = projects

        s.__package_name = None

        # If a bug isn't to be processed, detect this as early as possible.
        #
        s.is_valid = s.check_is_valid(s.lpbug)

        if s.is_valid:
            info('    Targeted Project:')
            info('        %s' % s.targeted_project)
            info('')
            s.properties = s.lpbug.properties
            if len(s.properties) > 0:
                info('    Properties:')
                for prop in s.properties:
                    info('        %s: %s' % (prop, s.properties[prop]))

            s.tasks_by_name = s.create_tasks_by_name()

    # check_is_valid
    #
    def check_is_valid(s, bug):
        '''
        '''
        retval = True
        for t in s.lpbug.tasks:
            task_name       = t.bug_target_name

            if task_name in s.projects:
                s.targeted_project = task_name
                if t.status == 'In Progress':
                    continue
                else:
                    info('        Not processing this bug because master task state is set to %s' % (t.status))
                    info('        Quitting this bug')
                    retval = False

        return retval

    # create_tasks_by_name
    #
    def create_tasks_by_name(s):
        '''
        We are only interested in the tasks that are specific to the workflow project. Others
        are ignored.
        '''
        taskbyname = {}

        info('')
        info('    Scanning bug tasks:')

        for t in s.lpbug.tasks:
            task_name       = t.bug_target_name

            if task_name.startswith(s.targeted_project):
                if '/' in task_name:
                    task_name = task_name[len(s.targeted_project)+1:].strip()
                taskbyname[task_name] = WorkflowBugTask(t, task_name)
            else:
                info('')
                info('        %-25s' % (task_name))
                info('            Action: Skipping non-workflow task')

        return taskbyname

# BS
#
class BS(object):
    '''
    Build Status
    '''
    # __init__
    #
    def __init__(s, status, package):
        '''
        0 - if the package-version wasn't found/published. In this case
            the package creator and assignee returned is always None
        1 - if the package-version is available (published), but still
            didn't finish building
        2 - package-version is available in the archive
        '''
        s.status = status
        s.package = package

    @property
    def is_built_and_published(s):
        return s.status == 2

# Package
#
class Package():

    # __init__
    #
    def __init__(s, lp, shankbug):
        s.ubuntu = Ubuntu()
        s.lp = lp
        s.__distro_series = None
        s.__is_new_abi = None

        ckt = s.lp.launchpad.people['canonical-kernel-team']
        s.ckt_ppa = ckt.getPPAByName(name='ppa')

        s.main_archive = s.lp.launchpad.distributions["ubuntu"].main_archive

        s.bug = shankbug

        # Determine some properties of the package we are looking at based on the
        # bug title. This information is used further on.
        #
        s.package = PackageInfo(s.bug.lpbug.title)
        if not s.package.valid:
            warning('        Unable to check package builds for this bug: either the package name or')
            warning('        the version are not properly indicated in the bug title.')
            raise PackageError(['Unable to check package builds for this bug: either the package name or',
                                'the version are not properly indicated in the bug title.'])

        s.pkgs = s.dependent_packages

        if shankbug.targeted_project == 'kernel-sru-workflow':
            s.is_stable_package = True
        else:
            s.is_stable_package = False

    # distro_series
    #
    @property
    def distro_series(s):
        '''
        Return the LP distro series link to the series associated with this version
        of this package.
        '''
        if s.__distro_series is None:
            series = s.ubuntu.series_name(s.package.name, s.package.version)
            if series:
                sc = s.lp.launchpad.distributions["ubuntu"].series_collection
                for ds in sc:
                    if ds.name == series:
                        s.__distro_series = ds
                        break

            if s.__distro_series is None:
                emsg = "        ERROR: can't figure out the distro series for %s-%s\n" % (s.package.name, s.package.version)
                error(emsg)
                raise ErrorExit(emsg)

        return s.__distro_series

    # is_new_abi
    #
    @property
    def is_new_abi(s):
        '''
        Try to determine if there was an abi change in this release. We
        guess this by looking if there is already a package with same
        abi in the updates/release pocket.
        '''
        if s.__is_new_abi is None:
            s.__is_new_abi = True
            if s.package.kernel and s.package.abi:
                st_abi_rel, _ = s.build_status(s.package.name, s.package.abi, s.main_archive, s.package.kernel, 'Release')
                st_abi_upd, _ = s.build_status(s.package.name, s.package.abi, s.main_archive, s.package.kernel, 'Updates')
                if st_abi_rel == 2 or st_abi_upd == 2:
                    s.__is_new_abi = False

        return s.__is_new_abi

    # dependent_packages
    #
    @property
    def dependent_packages(s):
        '''
        Put together a list of all the packages that depend on this package.
        '''
        pkgs = {}
        series = s.ubuntu.series_name(s.package.name, s.package.version)
        entry = s.ubuntu.lookup(series)
        if entry:
            if 'dependent-packages' in entry:
                if s.package.name in entry['dependent-packages']:
                    pkgs.update(entry['dependent-packages'][s.package.name])

        # The package depends upon itself
        #
        pkgs['main'] = s.package.name

        return pkgs

    # determine_build_status
    #
    def determine_build_status(s):
        """
        Verify the required packages for this update, and determine its
        build status
        """
        # Check build status. This is really convoluted... due to number
        # of tasks and we wanting the better behaviour as possible
        promoted_to_updates = True
        promoted_to_security = True
        promoted_to_release = True
        pkg_security = None
        pkg_updates = None
        pkg_release = None

        info('    Processing depenent packages:')
        for dep in iter(s.pkgs):
            info('')
            info('        %s:' % dep)

            abi_num = None
            pkg_rel = s.package.version
            if dep in [ 'lbm', 'lrm', 'lum', 'meta', 'ports-meta' ] and s.package.abi:
                abi_num = s.package.abi
                pkg_rel = s.package.kernel

            status_updates = 0
            status_release = 0
            prepare_status = 0
            prepare_assignee = None
            prepare_uploader = None

            if s.is_stable_package:
                promoted_to_release = False
                status_ckt,      pkg_ckt      = s.build_status(s.pkgs[dep], abi_num, s.ckt_ppa,    pkg_rel)
                status_proposed, pkg_proposed = s.build_status(s.pkgs[dep], abi_num, s.main_archive, pkg_rel, 'Proposed')

                status_security, pkg_security = s.build_status(s.pkgs[dep], abi_num, s.main_archive, pkg_rel, 'Security')
                if status_security != 2:
                    promoted_to_security = False # Not in the Security pocket

                status_updates,  pkg_updates  = s.build_status(s.pkgs[dep], abi_num, s.main_archive, pkg_rel, 'Updates')
                if status_updates != 2:
                    promoted_to_updates = False  # Not in the Updates pocket

                for st in [ status_ckt, status_proposed, status_updates ]:
                    if st > prepare_status:
                        prepare_status = st

                for c in [ pkg_ckt, pkg_proposed, pkg_updates, pkg_security ]:
                    if c:
                        prepare_assignee = c.package_creator
                        prepare_uploader = c.package_signer
                        break
            else:
                promoted_to_updates = False
                promoted_to_security = False

                status_release,  pkg_release  = s.build_status(s.pkgs[dep], abi_num, s.main_archive, pkg_rel, 'Release')
                if status_release != 2:
                    promoted_to_release = False
                if pkg_release:
                    prepare_assignee = pkg_release.package_creator
                    prepare_uploader = pkg_release.package_signer

                status_proposed, pkg_proposed = s.build_status(s.pkgs[dep], abi_num, s.main_archive, pkg_rel, 'Proposed')
                prepare_status = status_proposed
                if status_release > prepare_status:
                    prepare_status = status_release
                if pkg_proposed:
                    prepare_assignee = pkg_proposed.package_creator
                    prepare_uploader = pkg_proposed.package_signer

            task_status = [ 'New', 'In Progress', 'Fix Released' ]  # FIXME bjf - should probably just be a class variable

            if s.pkgs[dep] == s.package.name:  # if 'linux' == 'linux'
                prep_task_name = 'prepare-package'
            else:
                prep_task_name = 'prepare-package-%s' % (dep)
            prep_task_status = s.bug.tasks_by_name[prep_task_name].status

            # When things are moved from one pocket to another, things
            # may be unavailable for some time, and we may think no
            # packages were built. Thus we add a tagged timestamp,
            # marking the time when we detect that the builds are
            # missing. If after 1 hour the builds are still unavailable,
            # then we allow to reset the tasks.
            prop = 'kernel-%s-build-unavailable' % (dep)
            if (s.bug.tasks_by_name[prep_task_name].status == 'Fix Released' and prepare_status != 2):
                s.set_tagged_timestamp(s.bug.tasks_by_name[prep_task_name], prop)
                if not prop in s.bug.lpbug.properties:
                    warning('Fix Released bug not fully built?!?')
                    continue # Nothing further to do, process the next dependent package.

                date_str = s.bug.lpbug.properties[prop]
                timestamp = datetime.strptime(date_str, '%A, %d. %B %Y %H:%M UTC')
                delta = DeltaTime(timestamp, datetime.utcnow())
                if delta.hours < 1:
                    info('        Builds gone for %s, waiting 1 hour to reset tasks' % (prep_task_name))
                    warning('Fix Released bug not fully built?!? (waiting)')
                    continue # Nothing further to do, process the next dependent package.

            # Clear the timestamp property if it was set. We just clean it up so it doesn't
            # confuse anyone looking at the bug.
            #
            if prop in s.bug.lpbug.properties:
                s.props.set({prop:None})

            new_status = s.bug.tasks_by_name[prep_task_name].status
            if abi_num:
                if s.is_new_abi:
                    new_status = task_status[prepare_status]
                else:
                    if new_status not in ['Invalid', 'Fix Released']:
                        new_status = 'Invalid'
            else:
                new_status = task_status[prepare_status]

            # FIXME bjf - if prepare_assignee and new_status != 'Invalid':
            # FIXME bjf -     s.set_task_assignee(prep_task_name, prepare_assignee)

            # FIXME bjf - s.set_task_to_state(prep_task_name, new_status)
            info('            %s - current: %s; new: %s' % (prep_task_name, prep_task_status, new_status))

            # Take care of the upload-to-ppa task if needed
            # FIXME bjf - if dep == 'main' and 'upload-to-ppa' in s.bug.tasks_by_name:
            # FIXME bjf -     if prepare_uploader:
            # FIXME bjf -         s.set_task_assignee('upload-to-ppa', prepare_uploader)
            # FIXME bjf -     if prepare_status >= 1:
            # FIXME bjf -         s.set_task_to_state('upload-to-ppa', 'Fix Released')
            # FIXME bjf -     elif s.bug.tasks_by_name['upload-to-ppa'].status != 'Confirmed':
            # FIXME bjf -         s.set_task_to_state('upload-to-ppa', 'New')

        info('')
        info('    promoted_to_security: %s' % promoted_to_security)
        info('     promoted_to_updates: %s' % promoted_to_updates)
        info('     promoted_to_release: %s' % promoted_to_release)
        ###################################################################
        #
        return # FIXME bjf -debug

        # Set promotion bug tasks
        if promoted_to_security:
            if pkg_security:
                s.set_task_assignee('promote-to-security', pkg_security.creator)
            s.set_task_to_state('promote-to-security', 'Fix Released')

        if promoted_to_updates:
            if pkg_updates:
                s.set_task_assignee('promote-to-updates', pkg_updates.creator)
            s.set_task_to_state('promote-to-updates', 'Fix Released')

        if promoted_to_release:
            if pkg_release:
                s.set_task_assignee('promote-to-release', pkg_release.creator)
            s.set_task_to_state('promote-to-release', 'Fix Released')

    # is_released
    #
    @property
    def is_released(s):
        '''
        Determine if the 'promote' tasks have all been set to 'Fix Released'.
        '''
        retval = False

        if s.is_stable_package:
            if ((s.bug.tasks_by_name['promote-to-security'].status == 'Fix Released') and
                (s.bug.tasks_by_name['promote-to-updates'].status == 'Fix Released')):
                retval = True
        else:
            if s.bug.tasks_by_name['promote-to-release'].status == 'Fix Released':
                retval = True
        return retval

    # is_prepd
    #
    @property
    def is_prepd(s):
        '''
        Determine if the main package and all it's dependents have been prepared.
        '''
        retval = True
        info('    Prep\'d Check:')
        for dep in iter(s.pkgs):
            if s.pkgs[dep] == s.package.name:  # if 'linux' == 'linux'
                prep_task_name = 'prepare-package'
            else:
                prep_task_name = 'prepare-package-%s' % (dep)

            prep_task_status = s.bug.tasks_by_name[prep_task_name].status
            if prep_task_status != 'Fix Released':
                info('        %s: not fully prep\'d' % dep)
                retval = False
                break
            else:
                info('        %s: fully prep\'d' % dep)

        return retval

    def get_sources(s, archive, package, release=None, pocket=''):
        if release is not None:
            if pocket != '':
                ps = archive.getPublishedSources(distro_series=s.distro_series, exact_match=True, source_name=package, status='Published', version=release, pocket=pocket)
                #error('get_sources #1')
            else:
                ps = archive.getPublishedSources(distro_series=s.distro_series, exact_match=True, source_name=package, status='Published', version=release)
                #error('get_sources #2')
        else:
            if pocket != '':
                ps = archive.getPublishedSources(distro_series=s.distro_series, exact_match=True, source_name=package, status='Published', pocket=pocket)
                #error('get_sources #3')
            else:
                ps = archive.getPublishedSources(distro_series=s.distro_series, exact_match=True, source_name=package, status='Published')
                #error('get_sources #4')
        return ps

    def build_status(s, package, abi, archive, release=None, pocket=''):
        """
        Return an status code, the possible assignee responsible and the
        package creator related to the publishing of the package in the
        given archive on the optionally specified pocket (if we want the
        check to be restricted on a specific pocket). The following
        values are returned as the status code:
        0 - if the package-version wasn't found/published. In this case
            the package creator and assignee returned is always None
        1 - if the package-version is available (published), but still
            didn't finish building
        2 - package-version is available in the archive

        The parameters are:
          package   - the package name
          release   - the version or version-abi number to match
          abi_match - if provided, indicates that release is not an exact
                      version number, and we must do an ABI check
          archive   - launchpad archive to look into
          pocket    - optional, if we want only results of the archive from
                      the specified pocket
        """

        info('            ---------------------------------------------------------------------------')
        info('            Build Status')
        info('')
        info('                package: %s' % package)
        info('                    abi: %s' % abi)
        info('                archive: %s' % archive)
        info('                release: %s' % release)
        info('                 pocket: %s' % pocket)
        info('')

        #ps = s.get_sources(archive, package, release, pocket)
        #if not abi:
        #    ps = s.get_sources(archive, package, release, pocket)
        if pocket and not abi:
            #error('build_status #1')
            ps = s.get_sources(archive, package, release, pocket)
        elif not pocket and not abi:
            #error('build_status #2')
            ps = s.get_sources(archive, package, release)
        elif pocket and abi:
            #error('build_status #3')
            ps = s.get_sources(archive, package, pocket=pocket)
        else:
            #error('build_status #4')
            ps = s.get_sources(archive, package)

        matches = []
        if abi:
            dep_ver1 = '%s-%s' % (release, abi)
            dep_ver2 = '%s.%s' % (release, abi)
            rel_match = '<%s> or <%s>' % (dep_ver1, dep_ver2)
            for p in ps:
                src_ver = p.source_package_version
                info('                src_ver: %s' % src_ver)
                if ((src_ver.startswith(dep_ver1 + '.') or src_ver.startswith(dep_ver2 + '.'))):
                    matches.append(p)
        else:
            rel_match = '<%s>' % (release)
            for p in ps:
                matches.append(p)

        retval = 0, None
        if not matches:
            info('                Can\'t find <%s> (%s) build on %s (pocket:%s)' % (package, rel_match, archive.displayname, pocket))
        else:
            lst_date = None
            for pkg in matches:
                src_id = str(pkg.self).rsplit('/', 1)[1]
                build_summaries = archive.getBuildSummariesForSourceIds(source_ids=[src_id])[src_id]
                if build_summaries['status'] == 'FULLYBUILT':
                    info('                <%s> %s built (pocket:%s)' % (package, rel_match, pocket))
                    bs = 2
                else:
                    info('                <%s> %s not fully built yet, skipping (pocket:%s)' % (package, rel_match, pocket))
                    bs = 1
                # prefer newer published items...
                if lst_date:
                    if lst_date > pkg.date_published:
                        continue
                lst_date = pkg.date_published
                retval = bs, pkg

        info('                result: %d, %s' % retval)
        return retval

class TaskActions(dict):
    # __init__
    #
    def __init__(s, d, *args):
        dict.__init__(s, *args)
        s.actions = {}
        for t in ['New', 'Incomplete', 'Opinion', 'Invalid', 'Won\'t Fix', 'Expired', 'Confirmed', 'Triaged', 'In Progress', 'Fix Committed', 'Fix Released', 'Unknown']:
            s[t] = {}
            s[t]['action'] = None

        for k in d:
            s[k] = {}
            s[k]['action'] = d[k]

# Shankbot
#
class Shankbot():
    '''
    '''

    # __init__
    #
    def __init__(s, lp, lpserver, projects):
        s.lp = lp
        s.lpserver = lpserver
        s.projects = projects

        s.state_map = {
            'upload-to-ppa'             : TaskActions({}),
            'prepare-package'           : TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'prepare-package-lbm'       : TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'prepare-package-lrm'       : TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'prepare-package-lum'       : TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'prepare-package-meta'      : TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'prepare-package-ports-meta': TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'prepare-package-signed'    : TaskActions({'Fix Released' : s.prep_package_fix_released}),
            'promote-to-proposed'       : TaskActions({'Fix Released' : s.promote_to_proposed_fix_released}),
            'verification-testing'      : TaskActions({'Fix Released' : s.verification_testing_fix_released}),
            'certification-testing'     : TaskActions({'Fix Released' : s.certification_testing_fix_released}),
            'regression-testing'        : TaskActions({'Fix Released' : s.regression_testing_fix_released}),
            'package-testing'           : TaskActions({'Fix Released' : s.package_testing_fix_released}),
            'promote-to-updates'        : TaskActions({'Fix Released' : s.check_for_final_close}),
            'promote-to-security'       : TaskActions({'Fix Released' : s.check_for_final_close}),
            'promote-to-release'        : TaskActions({'Fix Released' : s.promote_to_release_fix_released}),
            'security-signoff'          : TaskActions({'Invalid'      : s.security_signoff_finished,
                                                       'Fix Released' : s.security_signoff_finished}),
        }

    def security_signoff_finished(s):
        pass

    def promote_to_release_fix_released(s):
        pass

    def check_for_final_close(s):
        pass

    def package_testing_fix_released(s):
        pass

    def regression_testing_invalid(s):
        pass

    def certification_testing_fix_released(s):
        pass

    def certification_testing_invalid(s):
        pass

    def verification_testing_fix_released(s):
        pass

    def promote_to_proposed_fix_released(s):
        pass

    def prep_package_fix_released(s):
        pass

    def regression_testing_fix_released(s):
        pass

    # bug_url
    #
    def bug_url(s, bug_id):
        retval = 'https://%s/bugs/%s' % (s.lpserver, bug_id)
        return retval

    # process_bug_tasks
    #
    def process_bug_tasks(s, shankbug):
        info('')
        info('    Processing Workflow Tasks:')

        for workflow_task_name in sorted(shankbug.tasks_by_name):
            task = shankbug.tasks_by_name[workflow_task_name]
            info("        %-25s  %15s  %10s  %s" % (task.name, task.status, task.importance, task.assignee))

            if task.name not in s.state_map:
                info(s.printlink)
                info("            Warning: I don't know how to handle the task <%s>, skipping" % (task.name))
                continue

            if 'action' not in s.state_map[task.name][task.status]:
                info(s.printlink)
                info("            Error: No action found for state <%s> and task <%s>" % (task.status, task.name))
                raise ValueError

            action = s.state_map[task.name][task.status]['action']

            if  action is None:
                info('            Action: No action for task %s in state %s\n' % (task.name, task.status))

    # shank
    #
    def shank(s, bugid):
        s.printlink =  '%s : (%s)' % (bugid, s.bug_url(bugid)),
        info('')
        info('Processing: %s' % s.printlink)

        bug = WorkflowBug(s.lp, s.projects, bugid)
        if bug.is_valid:
            try:
                p = Package(s.lp, bug)
                info('')
                if p.is_released:
                    info('        The package has been promoted to the approriate release directories. Nothing more to be done.')

                elif p.is_prepd:
                    info('        The package and all of it\'s dependents have been fully prepared.')

                else:
                    info('        Needs work')
                    p.determine_build_status(bug)

                s.process_bug_tasks(bug)

            except PackageError:
                pass

# TheApp
#
class TheApp():
    '''
    '''

    # __init__
    #
    def __init__(s, args):
        s.args = args

        lp_cfg = {}
        lp_cfg['launchpad_client_name'] = 'kernel-team-sru-workflow-manager'
        if s.args.staging:
            lp_cfg['launchpad_services_root'] = 'qastaging'
            s.lpserver = 'bugs.qastaging.launchpad.net'
        else:
            s.lpserver = 'bugs.launchpad.net'
        s.lp = LaunchpadService(lp_cfg)

    def get_buglist(s, project):
        retval = []

        search_tags            = [   # A list of the tags we care about
                'kernel-release-tracking-bug'
            ]
        search_tags_combinator = "All"
        search_status          = ["New", "In Progress", "Incomplete", "Fix Committed"] # A list of the bug statuses that we care about
        search_since           = datetime(year=2013, month=1, day=1)
        lp_project = s.lp.projects[project]
        tasks = lp_project.search_tasks(status=search_status, tags=search_tags, tags_combinator=search_tags_combinator, modified_since=search_since)

        for task in tasks:
            bug = task.bug
            info('found: %s' % bug.id)
            retval.append(bug.id)

        return retval

    # main
    #
    def main(s):
        retval = 1
        try:
            debug('Starting ...')

            projects_tracked = [ 'kernel-development-workflow', 'kernel-sru-workflow' ]
            bot = Shankbot(s.lp, s.lpserver, projects_tracked)
            if s.args.bugs:
                for bug in s.args.bugs:
                    bot.shank(bug)

            else:
                for project in projects_tracked:
                    info('Project: %s' % project)

                    for bug in s.get_buglist(project):
                        bot.shank(bug)

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            error("Aborting ...")

        if retval > 0:
            error("")
            error("Due to the above error(s), this script is unable to continue and is terminating.")
            error("")

        debug('That\'s All Folks!')
        return retval

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I do increadible things to kernel workflow bugs.
    '''
    app_epilog = '''
examples:
    sb
    sb --verbose
    sb --verbose --dry-run
    sb --verbose --staging
    sb --bugs=1134424,1133589
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--verbose', action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--dry-run', action='store_true', default=False, help='Don\'t modify the bug(s). Should be used with --verbose.')
    parser.add_argument('--staging', action='store_true', default=False, help='Use the staging LP service instead of the production one.')
    parser.add_argument('--bugs',                         default=None,  help='A comma seperated list of bug ids. Only these bug ids will be processed.')
    parser.add_argument('--log-file',                     default=None,  help='Where to log the output.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.verbose:
        basicConfig(filename=args.log_file, level=DEBUG, format=log_format)
    else:
        basicConfig(filename=args.log_file, level=INFO, format=log_format)

    if args.bugs:
        args.bugs = args.bugs.replace(' ', '')
        if ',' in args.bugs:
            args.bugs = args.bugs.split(',')
        else:
            args.bugs = [args.bugs]

    app = TheApp(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab syntax=python:
