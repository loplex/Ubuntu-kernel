#!/usr/bin/env python
#

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import info, debug, error, warning, basicConfig, INFO, DEBUG, WARNING

from datetime                           import datetime
from lpltk.LaunchpadService             import LaunchpadService

from sb.package                         import Package, PackageError
from sb.th.prep_package                 import PrepPackage
from sb.th.promote_to_proposed          import PromoteToProposed
from sb.th.verification_testing         import VerificationTesting
from sb.th.certification_testing        import CertificationTesting
from sb.th.regression_testing           import RegressionTesting
from sb.th.package_testing              import PackageTesting
from sb.th.closer                       import Closer
from sb.th.promote_to_release           import PromoteToRelease
from sb.th.security_signoff             import SecuritySignoff


# WorkflowBugTask
#
class WorkflowBugTask(object):
    # __init__
    #
    def __init__(s, lp_task, task_name):
        setattr(s, 'name', task_name)
        setattr(s, 'status', lp_task.status)
        setattr(s, 'importance', lp_task.importance)
        setattr(s, 'lp_task', lp_task)

        assignee    = lp_task.assignee
        if assignee is None:
            setattr(s, 'assignee', '*Unassigned')
        else:
            setattr(s, 'assignee', assignee.display_name)

# WorkflowBug
#
class WorkflowBug():
    # __init__
    #
    def __init__(s, lp, projects, bugid):
        s.lp = lp
        s.lpbug = s.lp.get_bug(bugid)
        s.projects = projects

        s.__package_name = None

        # If a bug isn't to be processed, detect this as early as possible.
        #
        s.is_valid = s.check_is_valid(s.lpbug)

        if s.is_valid:
            info('    Targeted Project:')
            info('        %s' % s.targeted_project)
            info('')
            s.properties = s.lpbug.properties
            if len(s.properties) > 0:
                info('    Properties:')
                for prop in s.properties:
                    info('        %s: %s' % (prop, s.properties[prop]))

            s.tasks_by_name = s.create_tasks_by_name()

    # check_is_valid
    #
    def check_is_valid(s, bug):
        '''
        '''
        retval = True
        for t in s.lpbug.tasks:
            task_name       = t.bug_target_name

            if task_name in s.projects:
                s.targeted_project = task_name
                if t.status == 'In Progress':
                    continue
                else:
                    info('        Not processing this bug because master task state is set to %s' % (t.status))
                    info('        Quitting this bug')
                    retval = False

        return retval

    # create_tasks_by_name
    #
    def create_tasks_by_name(s):
        '''
        We are only interested in the tasks that are specific to the workflow project. Others
        are ignored.
        '''
        taskbyname = {}

        info('')
        info('    Scanning bug tasks:')

        for t in s.lpbug.tasks:
            task_name       = t.bug_target_name

            if task_name.startswith(s.targeted_project):
                if '/' in task_name:
                    task_name = task_name[len(s.targeted_project)+1:].strip()
                taskbyname[task_name] = WorkflowBugTask(t, task_name)
            else:
                info('')
                info('        %-25s' % (task_name))
                info('            Action: Skipping non-workflow task')

        return taskbyname

# BS
#
class BS(object):
    '''
    Build Status
    '''
    # __init__
    #
    def __init__(s, status, package):
        '''
        0 - if the package-version wasn't found/published. In this case
            the package creator and assignee returned is always None
        1 - if the package-version is available (published), but still
            didn't finish building
        2 - package-version is available in the archive
        '''
        s.status = status
        s.package = package

    @property
    def is_built_and_published(s):
        return s.status == 2

class TaskActions(dict):
    # __init__
    #
    def __init__(s, d, *args):
        dict.__init__(s, *args)
        s.actions = {}
        for t in ['New', 'Incomplete', 'Opinion', 'Invalid', 'Won\'t Fix', 'Expired', 'Confirmed', 'Triaged', 'In Progress', 'Fix Committed', 'Fix Released', 'Unknown']:
            s[t] = None

        for k in d:
            s[k] = d[k]

# Shankbot
#
class Shankbot():
    '''
    '''

    # __init__
    #
    def __init__(s, lp, lpserver, projects):
        s.lp = lp
        s.lpserver = lpserver
        s.projects = projects

        s.sm = {
            'upload-to-ppa'             : TaskActions({}),
            'prepare-package'           : TaskActions({'Fix Released' : PrepPackage}),
            'prepare-package-lbm'       : TaskActions({'Fix Released' : PrepPackage}),
            'prepare-package-lrm'       : TaskActions({'Fix Released' : PrepPackage}),
            'prepare-package-lum'       : TaskActions({'Fix Released' : PrepPackage}),
            'prepare-package-meta'      : TaskActions({'Fix Released' : PrepPackage}),
            'prepare-package-ports-meta': TaskActions({'Fix Released' : PrepPackage}),
            'prepare-package-signed'    : TaskActions({'Fix Released' : PrepPackage}),
            'promote-to-proposed'       : TaskActions({'Fix Released' : PromoteToProposed}),
            'verification-testing'      : TaskActions({'Fix Released' : VerificationTesting}),
            'certification-testing'     : TaskActions({'Fix Released' : CertificationTesting}),
            'regression-testing'        : TaskActions({'Fix Released' : RegressionTesting}),
            'package-testing'           : TaskActions({'Fix Released' : PackageTesting}),
            'promote-to-updates'        : TaskActions({'Fix Released' : Closer}),
            'promote-to-security'       : TaskActions({'Fix Released' : Closer}),
            'promote-to-release'        : TaskActions({'Fix Released' : PromoteToRelease}),
            'security-signoff'          : TaskActions({'Invalid'      : SecuritySignoff, 'Fix Released' : SecuritySignoff}),
        }

    # bug_url
    #
    def bug_url(s, bug_id):
        retval = 'https://%s/bugs/%s' % (s.lpserver, bug_id)
        return retval

    # process_bug_tasks
    #
    def process_bug_tasks(s, shankbug):
        info('')
        info('    Processing Workflow Tasks:')

        for workflow_task_name in sorted(shankbug.tasks_by_name):
            if workflow_task_name in ['kernel-sru-workflow', 'kernel-development-workflow']:
                continue

            task = shankbug.tasks_by_name[workflow_task_name]
            info("        %-25s  %15s  %10s  %s" % (task.name, task.status, task.importance, task.assignee))

            if workflow_task_name not in s.sm:
                info('            ' + s.printlink)
                info('            Warning: I don\'t know how to handle the task <%s>, skipping' % (workflow_task_name))
                continue

            handler = s.sm[workflow_task_name][task.status]

            if handler is None:
                info('            Action: No action for task %s in state %s' % (workflow_task_name, task.status))

            else:
                handler(task).action()

                #if s.projectname == 'kernel-sru-workflow' and res_action:
                #    performReleaseTest = True

            info('')


    # shank
    #
    def shank(s, bugid):
        s.printlink =  '%s : (%s)' % (bugid, s.bug_url(bugid)),
        info('')
        info('Processing: %s' % s.printlink)

        bug = WorkflowBug(s.lp, s.projects, bugid)
        if bug.is_valid:
            try:
                p = Package(s.lp, bug)
                info('')
                if p.is_released:
                    info('        The package has been promoted to the approriate release directories. Nothing more to be done.')

                elif p.is_prepd:
                    info('        The package and all of it\'s dependents have been fully prepared.')

                else:
                    info('        Needs work')
                    p.determine_build_status(bug)

                s.process_bug_tasks(bug)

            except PackageError:
                pass

# TheApp
#
class TheApp():
    '''
    '''

    # __init__
    #
    def __init__(s, args):
        s.args = args

        lp_cfg = {}
        lp_cfg['launchpad_client_name'] = 'kernel-team-sru-workflow-manager'
        if s.args.staging:
            lp_cfg['launchpad_services_root'] = 'qastaging'
            s.lpserver = 'bugs.qastaging.launchpad.net'
        else:
            s.lpserver = 'bugs.launchpad.net'
        s.lp = LaunchpadService(lp_cfg)

    def get_buglist(s, project):
        retval = []

        search_tags            = [   # A list of the tags we care about
                'kernel-release-tracking-bug'
            ]
        search_tags_combinator = "All"
        search_status          = ["New", "In Progress", "Incomplete", "Fix Committed"] # A list of the bug statuses that we care about
        search_since           = datetime(year=2013, month=1, day=1)
        lp_project = s.lp.projects[project]
        tasks = lp_project.search_tasks(status=search_status, tags=search_tags, tags_combinator=search_tags_combinator, modified_since=search_since)

        for task in tasks:
            bug = task.bug
            info('found: %s' % bug.id)
            retval.append(bug.id)

        return retval

    # main
    #
    def main(s):
        retval = 1
        try:
            debug('Starting ...')

            projects_tracked = [ 'kernel-development-workflow', 'kernel-sru-workflow' ]
            bot = Shankbot(s.lp, s.lpserver, projects_tracked)
            if s.args.bugs:
                for bug in s.args.bugs:
                    bot.shank(bug)

            else:
                for project in projects_tracked:
                    info('Project: %s' % project)

                    for bug in s.get_buglist(project):
                        bot.shank(bug)

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            error("Aborting ...")

        if retval > 0:
            error("")
            error("Due to the above error(s), this script is unable to continue and is terminating.")
            error("")

        debug('That\'s All Folks!')
        return retval

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I do increadible things to kernel workflow bugs.
    '''
    app_epilog = '''
examples:
    sb
    sb --verbose
    sb --verbose --dry-run
    sb --verbose --staging
    sb --bugs=1134424,1133589
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--verbose', action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--dry-run', action='store_true', default=False, help='Don\'t modify the bug(s). Should be used with --verbose.')
    parser.add_argument('--staging', action='store_true', default=False, help='Use the staging LP service instead of the production one.')
    parser.add_argument('--bugs',                         default=None,  help='A comma seperated list of bug ids. Only these bug ids will be processed.')
    parser.add_argument('--log-file',                     default=None,  help='Where to log the output.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.verbose:
        basicConfig(filename=args.log_file, level=DEBUG, format=log_format)
    else:
        basicConfig(filename=args.log_file, level=INFO, format=log_format)

    if args.bugs:
        args.bugs = args.bugs.replace(' ', '')
        if ',' in args.bugs:
            args.bugs = args.bugs.split(',')
        else:
            args.bugs = [args.bugs]

    app = TheApp(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab syntax=python:
